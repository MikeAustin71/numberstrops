package numberstr

import (
	"fmt"
	"math/big"
	"sync"
)

type numStrDtoMolecule struct {
	lock *sync.Mutex
}

// compareNumStrDtoSignedValues - compares the signed numeric values
// of two NumStrDto objects. The two NumStrDto objects to be
// compared are passed as input parameters 'n1Dto' and 'n2Dto'.
// 'n1Dto' is compared to 'n2Dto' and the comparison result is
// returned as an integer value.
//
//     Return Values:
//     -1 = n1Dto is less than n2Dto
//      0 = n1Dto is equal to n2Dto
//     +1 = n1Dto is greater than n2Dto
//
// Examples:
//                          Integer
//                         Comparison
//   n1Dto     n2Dto         Result
//  -------------------------------
//  -9691.23   91.245         -1
//  9691.23	   91.245          1
//    -5       82             -1
//     5        5              0
//
// -----------------------------------------------------------------
//
// Input Parameters
//
//  n1Dto               *NumStrDto
//     - A pointer to an instance of NumStrDto. This method WILL
//       NOT CHANGE data values of internal member variables to
//       achieve the method's objectives.
//
//       This numeric value of this NumStrDto instance will be
//       compared to that of the second input parameter, 'n2Dto'.
//
//       If NumStrDto instance 'n1Dto' is judged to be invalid an
//       error will be returned.
//
//
//  n2Dto               *NumStrDto
//     - A pointer to an instance of NumStrDto. This method WILL
//       NOT CHANGE data values of internal member variables to
//       achieve the method's objectives.
//
//       This numeric value of this NumStrDto instance will be
//       compared to that of the second input parameter, 'n2Dto'.
//
//       If NumStrDto instance 'n2Dto' is judged to be invalid an
//       error will be returned.
//
//
//  ePrefix             *ErrPrefixDto
//     - This object encapsulates an error prefix string which is
//       included in all returned error messages. Usually, it
//       contains the names of the calling method or methods.
//
//
// -----------------------------------------------------------------
//
// Return Values
//
//  compareResult       int
//     - This comparison result is generated by comparing the numeric
//       values of input parameters 'n1Dto' and 'n2Dto'. If the method
//       completes successfully, this return parameter will be set to
//       one of three values thereby signaling the results of this
//       comparison.
//
//             'compareResult' Values
//         -1 = n1Dto is less than n2Dto
//          0 = n1Dto is equal to n2Dto
//         +1 = n1Dto is greater than n2Dto
//
//
//  err                 error
//     - If this method completes successfully, the returned error
//       Type is set equal to 'nil'.
//
//       If errors are encountered during processing, the returned
//       error Type will encapsulate an error message. This
//       returned error message will incorporate the method chain
//       and text passed by input parameter, 'ePrefix'. The
//       'ePrefix' text will be attached to the beginning of the
//       error message.
//
func (nStrDtoMolecule *numStrDtoMolecule) compareNumStrDtoSignedValues(
	n1Dto *NumStrDto,
	n2Dto *NumStrDto,
	ePrefix *ErrPrefixDto) (
	compareResult int,
	err error) {

	if nStrDtoMolecule.lock == nil {
		nStrDtoMolecule.lock = new(sync.Mutex)
	}

	nStrDtoMolecule.lock.Lock()

	defer nStrDtoMolecule.lock.Unlock()

	if ePrefix == nil {
		ePrefix = ErrPrefixDto{}.Ptr()
	}

	ePrefix.SetEPref(
		"numStrDtoMolecule.compareNumStrDtoSignedValues()")

	err = nil
	compareResult = -99

	if n1Dto == nil {
		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'n1Dto' has a 'nil' pointer!\n",
			ePrefix.String())

		return compareResult, err
	}

	if n2Dto == nil {
		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'n2Dto' has a 'nil' pointer!\n",
			ePrefix.String())

		return compareResult, err
	}

	nStrDtoQuark := numStrDtoQuark{}

	_,
		err = nStrDtoQuark.testNumStrDtoValidity(
		n1Dto,
		ePrefix.XCtx(
			"Testing 'n1Dto' Validity "))

	if err != nil {
		return compareResult, err
	}

	_,
		err = nStrDtoQuark.testNumStrDtoValidity(
		n2Dto,
		ePrefix.XCtx(
			"Testing 'n2Dto' Validity"))

	if err != nil {
		return compareResult, err
	}

	nStrDtoAtom := numStrDtoAtom{}

	var cmpAbs int

	cmpAbs,
		err = nStrDtoAtom.compareNumStrDtoAbsoluteValues(
		n1Dto,
		n2Dto,
		ePrefix.XCtx(
			"Comparing 'n1Dto' to 'n2Dto'"))

	if err != nil {
		return compareResult, err

	}

	if cmpAbs == 0 {

		if n1Dto.signVal == n2Dto.signVal {

			compareResult = 0

		} else {

			// n1Dto.signVal != n2Dto.signVal
			if n1Dto.signVal == 1 {

				compareResult = 1

			} else {

				// n2Dto.signVal must == 1
				compareResult = -1

			}

		}

		return compareResult, err
	}

	if cmpAbs == 1 {

		if n1Dto.signVal == n2Dto.signVal {

			if n1Dto.signVal == 1 {

				compareResult = 1

			} else {

				// must be n1Dto.signVal == n2Dto.signVal && n1Dto.signVal == -1
				compareResult = -1

			}

			return compareResult, err
		}

		// must be n1Dto.signVal != n2Dto.signVal
		if n1Dto.signVal == 1 {

			compareResult = 1

		} else {

			// must be n2Dto.signVal == 1
			compareResult = -1

		}

		return compareResult, err
	}

	// Must Be cmpAbs == -1

	if n2Dto.signVal == n1Dto.signVal {

		if n2Dto.signVal == 1 {

			// n1Dto.signVal && n2Dto.signVal must equal 1
			compareResult = -1

		} else {

			// n1Dto.signVal && n2Dto.signVal must equal -1
			compareResult = 1

		}

		return compareResult, err
	}

	// Must Be cmpAbs == -1
	// Must Be n2Dto.signVal != n1Dto.signVal

	if n2Dto.signVal == -1 {

		compareResult = 1

	} else {

		// must be n2Dto.signVal == 1
		compareResult = -1

	}

	return compareResult, err
}

// FormatForMathOps - receives two NumStrDto objects and converts their strings
// such that both have the same number of integer and fractional digits. This will
// facilitate the performance of string based math operations such as addition and
// subtraction.
//
// The return values represent the formatted NumStrDto objects. The first NumStrDto
// returned always contains the larger absolute value. The second NumStrDto always
// contains the absolute numeric value which is less than or equal to the first
// NumStrDto object returned.
//
// The third parameter returned by this method is an int which will always be set to
// 1 or 0. 1 indicates that the absolute value of the first NumStrDto returned by
// this method is greater than the second NumStrDto returned by this method. If
// the int value returned is zero, it signals that the absolute values
// (not the signed values) of both returned NumStrDto objects are equal.
//
//
// ------------------------------------------------------------------------
//
// Input Parameters
//
//  n1Dto               *NumStrDto
//     - A pointer to an instance of NumStrDto. This method WILL
//       NOT change the values of internal member variables to achieve
//       the method's objectives.
//
//
//  n2Dto               *NumStrDto
//     - A pointer to a second instance of NumStrDto. This method WILL
//       NOT change the values of internal member variables to achieve
//       the method's objectives.
//
//
//  ePrefix             *ErrPrefixDto
//     - This object encapsulates an error prefix string which is
//       included in all returned error messages. Usually, it
//       contains the names of the calling method or methods.
//
//       If error prefix information is NOT needed, set this
//       parameter to 'nil'.
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  n1DtoOut            NumStrDto
//     - This numeric value will always be greater than or equal to that
//       of n2DtoOut.
//
//
//  n2DtoOut            NumStrDto
//     - This numeric value will always be less than or equal to that
//       of n1DtoOut.
//
//
//  compare             int
//     - Set to one of two values: +1 or 0.
//
//       Plus 1 (+1) signals that the absolute value of 'n1DtoOut' is
//       greater than 'n2DtoOut'
//
//       Zero (0) signals that the absolute values (not the signed values)
//       of both 'n1DtoOut' and 'n2DtoOut' are equal.
//
//
//  isOrderReversed     bool
//     - If this returned boolean value is set to 'true', it signals that
//       returned parameter 'n1DtoOut' is equal to input parameter 'n2Dto'
//       and returned 'n2DtoOut' is equal to input parameter 'n1Dto'.
//
//       If 'isOrderReversed' is set to 'false',it signals that returned
//       parameter 'n1DtoOut' is equal to input parameter 'n1Dto'
//       and returned 'n2DtoOut' is equal to input parameter 'n2Dto'.
//
//
//  err                 error
//     - If this method completes successfully, the returned error
//       Type is set equal to 'nil'.
//
//       If errors are encountered during processing, the returned
//       error Type will encapsulate an error message. This
//       returned error message will incorporate the method chain
//       and text passed by input parameter, 'ePrefix'. The
//       'ePrefix' text will be attached to the beginning of the
//       error message.
//
func (nStrDtoMolecule *numStrDtoMolecule) formatForMathOps(
	n1Dto *NumStrDto,
	n2Dto *NumStrDto,
	ePrefix *ErrPrefixDto) (
	n1DtoOut NumStrDto,
	n2DtoOut NumStrDto,
	compare int,
	isOrderReversed bool,
	err error) {

	if nStrDtoMolecule.lock == nil {
		nStrDtoMolecule.lock = new(sync.Mutex)
	}

	nStrDtoMolecule.lock.Lock()

	defer nStrDtoMolecule.lock.Unlock()

	if ePrefix == nil {
		ePrefix = ErrPrefixDto{}.Ptr()
	}

	ePrefix.SetEPref("numStrDtoMolecule.formatForMathOps()")

	nStrDtoElectron := numStrDtoElectron{}
	compare = -99
	isOrderReversed = false
	err = nil

	n1DtoOut = nStrDtoElectron.newBaseZeroNumStrDto(
		0)

	n2DtoOut = nStrDtoElectron.newBaseZeroNumStrDto(
		0)

	if n1Dto == nil {

		err = fmt.Errorf("%v\n"+
			"\nInput parameter 'n1Dto' is INVALID!\n"+
			"n1Dto = nil pointer!\n",
			ePrefix.String())

		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	if n2Dto == nil {

		err = fmt.Errorf("%v\n"+
			"\nInput parameter 'n2Dto' is INVALID!\n"+
			"n2Dto = nil pointer!\n",
			ePrefix.String())

		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	lenN1AllRunes := 0
	lenN1IntRunes := 0
	lenN1FracRunes := 0
	lenN2AllRunes := 0
	lenN2IntRunes := 0
	lenN2FracRunes := 0

	nStrDtoQuark := numStrDtoQuark{}

	_,
		err =
		nStrDtoQuark.testNumStrDtoValidity(
			n1Dto,
			ePrefix.XCtx("n1Dto"))

	if err != nil {
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	_,
		err =
		nStrDtoQuark.testNumStrDtoValidity(
			n2Dto,
			ePrefix.XCtx("n2Dto"))

	if err != nil {
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	compare,
		err =
		numStrDtoAtom{}.ptr().
			compareNumStrDtoAbsoluteValues(
				n1Dto,
				n2Dto,
				ePrefix)

	if err != nil {
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	if compare == 1 {

		compare = 1

		n1DtoOut,
			err = nStrDtoElectron.copyOut(
			n1Dto,
			ePrefix)

		if err != nil {
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

		n2DtoOut,
			err = nStrDtoElectron.copyOut(
			n2Dto,
			ePrefix)

		if err != nil {
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

	} else if compare == -1 {

		n1DtoOut,
			err = nStrDtoElectron.copyOut(
			n2Dto,
			ePrefix)

		if err != nil {
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

		n2DtoOut,
			err = nStrDtoElectron.copyOut(
			n1Dto,
			ePrefix)

		if err != nil {
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

		isOrderReversed = true
		compare = 1

	} else {
		// compare must be zero

		compare = 0

		n1DtoOut,
			err = nStrDtoElectron.copyOut(
			n1Dto,
			ePrefix)

		if err != nil {
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

		n2DtoOut,
			err = nStrDtoElectron.copyOut(
			n2Dto,
			ePrefix)

		if err != nil {
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

	}

	var n1DtoOutAbsIntRunes, n1DtoOutAbsFracRunes,
		n2DtoOutAbsIntRunes, n2DtoOutAbsFracRunes []rune

	n1DtoOutAbsIntRunes,
		err =
		nStrDtoElectron.getAbsIntRunes(
			&n1DtoOut,
			ePrefix.XCtx("n1DtoOut"))

	if err != nil {
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	n1DtoOutAbsFracRunes,
		err =
		nStrDtoElectron.getAbsFracRunes(
			&n1DtoOut,
			ePrefix.XCtx("n1DtoOut"))

	if err != nil {
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	n2DtoOutAbsIntRunes,
		err =
		nStrDtoElectron.getAbsIntRunes(
			&n2DtoOut,
			ePrefix.XCtx("n2DtoOut"))

	if err != nil {
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	n2DtoOutAbsFracRunes,
		err =
		nStrDtoElectron.getAbsFracRunes(
			&n2DtoOut,
			ePrefix.XCtx("n2DtoOut"))

	if err != nil {
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	if n1DtoOut.precision > n2DtoOut.precision {

		deltaPrecision := n1DtoOut.precision - n2DtoOut.precision

		for i := uint(0); i < deltaPrecision; i++ {
			n2DtoOut.absAllNumRunes = append(n2DtoOut.absAllNumRunes, '0')
			n2DtoOutAbsFracRunes = append(n2DtoOutAbsFracRunes, '0')
		}

		lenN2AllRunes = len(n2DtoOut.absAllNumRunes)
		lenN2IntRunes = len(n2DtoOutAbsIntRunes)
		lenN2FracRunes = len(n2DtoOutAbsFracRunes)

		n2DtoOut.precision = n1DtoOut.precision

		_,
			err =
			nStrDtoQuark.testNumStrDtoValidity(
				&n2DtoOut,
				ePrefix.XCtx("n2DtoOut"))

		if err != nil {
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

		lenN1AllRunes = len(n1DtoOut.absAllNumRunes)
		lenN1IntRunes = len(n1DtoOutAbsIntRunes)
		lenN1FracRunes = len(n1DtoOutAbsFracRunes)

	} else if n1DtoOut.precision < n2DtoOut.precision {

		deltaPrecision := n2DtoOut.precision - n1DtoOut.precision

		for i := uint(0); i < deltaPrecision; i++ {
			n1DtoOut.absAllNumRunes = append(n1DtoOut.absAllNumRunes, '0')
			n1DtoOutAbsFracRunes = append(n1DtoOutAbsFracRunes, '0')
		}

		lenN1AllRunes = len(n1DtoOut.absAllNumRunes)
		lenN1IntRunes = len(n1DtoOutAbsIntRunes)
		lenN1FracRunes = len(n1DtoOutAbsFracRunes)

		n1DtoOut.precision = n2DtoOut.precision

		_,
			err =
			nStrDtoQuark.testNumStrDtoValidity(
				&n1DtoOut,
				ePrefix.XCtx("n1DtoOut"))

		if err != nil {
			n1DtoOut = NumStrDto{}
			n2DtoOut = NumStrDto{}
			compare = -99
			isOrderReversed = false
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

		lenN2AllRunes = len(n2DtoOut.absAllNumRunes)
		lenN2IntRunes = len(n2DtoOutAbsIntRunes)
		lenN2FracRunes = len(n2DtoOutAbsFracRunes)

	} else {
		// n1DtoOut.precision == n2DtoOut.precision

		lenN1AllRunes = len(n1DtoOut.absAllNumRunes)
		lenN1IntRunes = len(n1DtoOutAbsIntRunes)
		lenN1FracRunes = len(n1DtoOutAbsFracRunes)

		lenN2AllRunes = len(n2DtoOut.absAllNumRunes)
		lenN2IntRunes = len(n2DtoOutAbsIntRunes)
		lenN2FracRunes = len(n2DtoOutAbsFracRunes)

	}

	if lenN2IntRunes > lenN1IntRunes {

		var absAllRunes []rune
		var absIntRunes []rune
		deltaRunes := lenN2IntRunes - lenN1IntRunes
		for i := 0; i < deltaRunes; i++ {
			absAllRunes = append(absAllRunes, '0')
			absIntRunes = append(absIntRunes, '0')
		}

		for j := 0; j < lenN1AllRunes; j++ {
			absAllRunes = append(absAllRunes, n1DtoOut.absAllNumRunes[j])

			if j < lenN1IntRunes {
				absIntRunes = append(absIntRunes, n1DtoOutAbsIntRunes[j])
			}

		}

		n1DtoOut.absAllNumRunes = absAllRunes
		n1DtoOutAbsIntRunes = absIntRunes
		lenN1AllRunes = len(n1DtoOut.absAllNumRunes)
		lenN1IntRunes = len(n1DtoOutAbsIntRunes)

		_,
			err =
			nStrDtoQuark.testNumStrDtoValidity(
				&n1DtoOut,
				ePrefix.XCtx("n1DtoOut #2"))

		if err != nil {
			n1DtoOut = NumStrDto{}
			n2DtoOut = NumStrDto{}
			compare = -99
			isOrderReversed = false
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

	} else if lenN1IntRunes > lenN2IntRunes {

		var absAllRunes []rune
		var absIntRunes []rune
		deltaRunes := lenN1IntRunes - lenN2IntRunes
		for i := 0; i < deltaRunes; i++ {
			absAllRunes = append(absAllRunes, '0')
			absIntRunes = append(absIntRunes, '0')
		}

		for j := 0; j < lenN2AllRunes; j++ {
			absAllRunes = append(absAllRunes, n2DtoOut.absAllNumRunes[j])

			if j < lenN2IntRunes {
				absIntRunes = append(absIntRunes, n2DtoOutAbsIntRunes[j])
			}

		}

		n2DtoOut.absAllNumRunes = absAllRunes
		n2DtoOutAbsIntRunes = absIntRunes
		lenN2AllRunes = len(n2DtoOut.absAllNumRunes)
		lenN2IntRunes = len(n2DtoOutAbsIntRunes)

		_,
			err =
			nStrDtoQuark.testNumStrDtoValidity(
				&n2DtoOut,
				ePrefix.XCtx("n2DtoOut #2"))

		if err != nil {
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

	}

	if lenN1AllRunes != lenN2AllRunes {

		ePrefix.SetCtx("lenN1AllRunes != lenN2AllRunes")

		err = fmt.Errorf("%v\n"+
			"n1 and n2 AllNumRune arrays are NOT equal in length.\n"+
			"n1 length= '%v'\n"+
			"2 length= '%v'\n",
			ePrefix.String(),
			lenN1AllRunes,
			lenN2AllRunes)

		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	if lenN1IntRunes != lenN2IntRunes {

		ePrefix.SetCtx("lenN1IntRunes != lenN2IntRunes")

		err = fmt.Errorf("%v\n"+
			"n1 and n2 IntRunes arrays are NOT equal in length.\n"+
			"n1 length= '%v' n2 length= '%v'\n",
			ePrefix.String(),
			lenN1IntRunes,
			lenN2IntRunes)

		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	if lenN1FracRunes != lenN2FracRunes {

		ePrefix.SetCtx("lenN1FracRunes != lenN2FracRunes")

		err = fmt.Errorf("%v\n"+
			"n1 and n2 FracRunes arrays are NOT equal in length.\n"+
			"n1 length= '%v'\n"+
			"n2 length= '%v'\n",
			ePrefix.String(),
			lenN1FracRunes,
			lenN2FracRunes)

		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	if n1DtoOut.precision != n2DtoOut.precision {
		err = fmt.Errorf("FormatForMathOps() - n1 and n2 FracRunes arrays are NOT equal in length. "+
			"n1 length= '%v' n2 length= '%v'", lenN1FracRunes, lenN2FracRunes)

		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	_,
		err =
		nStrDtoQuark.testNumStrDtoValidity(
			&n1DtoOut,
			ePrefix.XCtx("n1DtoOut #3"))

	if err != nil {
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}
	_,
		err =
		nStrDtoQuark.testNumStrDtoValidity(
			&n2DtoOut,
			ePrefix.XCtx("n2DtoOut #3 "))

	if err != nil {
		n1DtoOut = NumStrDto{}
		n2DtoOut = NumStrDto{}
		compare = -99
		isOrderReversed = false
	}

	return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
}

// getNumStr - returns the numeric value of the current NumStrDto
// instance as a signed number string. The resulting number string
// will NOT contain a currency symbol or thousands separators. It
// will contain a decimal separator and fractional digits if such
// fractional digits exist.
//
// Note: If the current NumStrDto is invalid, this method will return
// an error.
//
// Examples:
//   123456.78
//  -123456.78
//
//
// ------------------------------------------------------------------------
//
// Input Parameters
//
//  numStrDto           *NumStrDto
//     - A pointer to an instance of NumStrDto. This method will
//       NOT change the values of internal member variables to achieve
//       the method's objectives. This NumStrDto will supply the
//       numeric value which will be used to create the returned
//       number string.
//
//
//  ePrefix             *ErrPrefixDto
//     - This object encapsulates an error prefix string which is
//       included in all returned error messages. Usually, it
//       contains the names of the calling method or methods.
//
//       If error prefix information is NOT needed, set this
//       parameter to 'nil'.
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//
//  numStr              string
//     - If this method completes successfully, the numeric value of the
//       current NumStrDto instance will be returned as a plain number
//       string with no thousands separator or currency symbol. Negative
//       values will be formatted with a leading minus sign.
//
//       Examples:
//         123456.78
//        -123456.78
//
//
//  err                 error
//     - If this method completes successfully, the returned error
//       Type is set equal to 'nil'.
//
//       If errors are encountered during processing, the returned
//       error Type will encapsulate an error message. This
//       returned error message will incorporate the method chain
//       and text passed by input parameter, 'ePrefix'. The
//       'ePrefix' text will be attached to the beginning of the
//       error message.
//
func (nStrDtoMolecule *numStrDtoMolecule) getNumStr(
	numStrDto *NumStrDto,
	ePrefix *ErrPrefixDto) (
	numStr string,
	err error) {

	if nStrDtoMolecule.lock == nil {
		nStrDtoMolecule.lock = new(sync.Mutex)
	}

	nStrDtoMolecule.lock.Lock()

	defer nStrDtoMolecule.lock.Unlock()

	if ePrefix == nil {
		ePrefix = ErrPrefixDto{}.Ptr()
	}

	ePrefix.SetEPref("numStrDtoMolecule.getNumStr()")

	numStr = ""
	err = nil

	if numStrDto == nil {

		err = fmt.Errorf("%v\n"+
			"Input parameter 'numStrDto' is INVALID!\n"+
			"numStrDto = nil pointer!\n",
			ePrefix.String())

		return numStr, err
	}

	nStrDtoQuark := numStrDtoQuark{}

	_,
		err = nStrDtoQuark.testNumStrDtoValidity(
		numStrDto,
		ePrefix.XCtx("Testing Validity of 'numStrDto'"))

	if err != nil {
		return numStr, err
	}

	nStrDtoAtom := numStrDtoAtom{}

	numStr,
		err = nStrDtoAtom.formatNumStr(
		numStrDto,
		LEADMINUSNEGVALFMTMODE,
		ePrefix.XCtx(
			"numStrDto, LEADMINUSNEGVALFMTMODE"))

	return numStr, err
}

// getSignedBigIntNum - Receives a NumStrDto and returns a type
// *big.Int integer value.
//
// ------------------------------------------------------------------------
//
// Input Parameters
//
//  numStrDto           *NumStrDto
//     - A pointer to an instance of NumStrDto. This method will
//       NOT change the values of internal member variables to achieve
//       the method's objectives. This NumStrDto will supply the
//       numeric value which will be used to create the returned
//       *big.Int value.
//
//
//  ePrefix             *ErrPrefixDto
//     - This object encapsulates an error prefix string which is
//       included in all returned error messages. Usually, it
//       contains the names of the calling method or methods.
//
//       If error prefix information is NOT needed, set this
//       parameter to 'nil'.
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//
//  bigIntNum           *big.Int
//     - If this method completes successfully, the numeric value
//       of input parameter 'numStrDto' will be returned as type a
//       type *big.Int integer value.
//
//
//  err                 error
//     - If this method completes successfully, the returned error
//       Type is set equal to 'nil'.
//
//       If errors are encountered during processing, the returned
//       error Type will encapsulate an error message. This
//       returned error message will incorporate the method chain
//       and text passed by input parameter, 'ePrefix'. The
//       'ePrefix' text will be attached to the beginning of the
//       error message.
//
func (nStrDtoMolecule *numStrDtoMolecule) getSignedBigIntNum(
	numStrDto *NumStrDto,
	ePrefix *ErrPrefixDto) (
	bigIntNum *big.Int,
	err error) {

	if nStrDtoMolecule.lock == nil {
		nStrDtoMolecule.lock = new(sync.Mutex)
	}

	nStrDtoMolecule.lock.Lock()

	defer nStrDtoMolecule.lock.Unlock()

	if ePrefix == nil {
		ePrefix = ErrPrefixDto{}.Ptr()
	}

	ePrefix.SetEPref(
		"numStrDtoMolecule.getSignedBigIntNum()")

	err = nil
	bigIntNum = big.NewInt(0)

	if numStrDto == nil {

		err = fmt.Errorf("%v\n"+
			"\nInput parameter 'numStrDto' is INVALID!\n"+
			"numStrDto = nil pointer!\n",
			ePrefix.String())

		return bigIntNum, err
	}

	_,
		err = numStrDtoQuark{}.ptr().testNumStrDtoValidity(
		numStrDto,
		ePrefix.XCtx(
			"Testing Validity of 'numStrDto'"))

	if err != nil {
		return bigIntNum, err
	}

	bigIntAbsVal := big.NewInt(0)

	bigIntAbsVal,
		err = numStrDtoAtom{}.ptr().getAbsoluteBigInt(
		numStrDto,
		ePrefix.XCtx("numStrDto"))

	if err != nil {
		return bigIntNum, err
	}

	if numStrDto.signVal < 0 {
		bigIntNum.Set(big.NewInt(0).Neg(bigIntAbsVal))
	} else {
		bigIntNum.Set(bigIntAbsVal)
	}

	return bigIntNum, err
}

// ptr - Returns a pointer to a new instance of numStrDtoMolecule.
//
func (nStrDtoMolecule numStrDtoMolecule) ptr() *numStrDtoMolecule {

	if nStrDtoMolecule.lock == nil {
		nStrDtoMolecule.lock = new(sync.Mutex)
	}

	nStrDtoMolecule.lock.Lock()

	defer nStrDtoMolecule.lock.Unlock()

	newNumStrDtoMolecule := new(numStrDtoMolecule)

	newNumStrDtoMolecule.lock = new(sync.Mutex)

	return newNumStrDtoMolecule
}

// SetPrecision - parses the incoming number string and applies the
// designated 'precision'.
//
// 'precision' determines the number of digits to the right of the
// decimal place. The boolean parameter 'roundResult' is used to
// apply rounding in those cases where 'precision' dictates a
// reduction in the number of digits to the right of the decimal
// place. See 'Examples' below.
//
//
// --------------------------------------------------------------------------------------------------
//
// Input Parameters
//
//  numStrFormatSpec    *NumStrFmtSpecDto
//     - This object contains all the formatting specifications
//       required to format numeric values contained in type
//       NumStrDto.
//
//       The NumStrDto instance ('newNumStrDto') returned by this
//       method will be configured with this Number String Format
//       Specification.
//
//       type NumStrFmtSpecDto struct {
//         idNo           uint64
//         idString       string
//         description    string
//         tag            string
//         countryCulture FormatterCountry
//         absoluteValue  FormatterAbsoluteValue
//         currencyValue  FormatterCurrency
//         signedNumValue FormatterSignedNumber
//         sciNotation    FormatterSciNotation
//       }
//
//
//  signedNumStr        string
//     - A valid number string. This string will be parsed and
//       configured with 'precision' digits to the right of the
//       decimal point before being converted to the NumStrDto
//       object returned to the calling function.
//
//
//  precision           uint
//     - The 'precision' values designates the number of places to the right of the
//       decimal point which will be realized upon completion of this operation.
//
//
//  roundResult         bool
//     - If the 'precision' value is less than the current number of places to the
//       right of the decimal point, this method will truncate the existing fractional
//       digits. If 'roundResult' is set to true, this truncation operation will
//       include rounding the last digit.
//
//
//  ePrefix             *ErrPrefixDto
//     - This object encapsulates an error prefix string which is
//       included in all returned error messages. Usually, it
//       contains the names of the calling method or methods.
//
//       If error prefix information is NOT needed, set this
//       parameter to 'nil'.
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  newNumStrDto        NumStrDto
//     - A new instance of NumStrDto encapsulating the numeric value
//       calculated from the input parameters.
//
//
//  err                 error
//     - If this method completes successfully, the returned error
//       Type is set equal to 'nil'.
//
//       If errors are encountered during processing, the returned
//       error Type will encapsulate an error message. This
//       returned error message will incorporate the method chain
//       and text passed by input parameter, 'ePrefix'. The
//       'ePrefix' text will be attached to the beginning of the
//       error message.
//
//
// ------------------------------------------------------------------------
//
// Example Usage
//
//       ------------ Input Parameters -----------      ---- Result --------
// Test
//  No   signedNumStr      precision   roundResult
//  ---- ------------------------------------------------------------------
//  1    "123456789"          7           false         "123456789.0000000"
//  2    "123456789"          7           true          "123456789.0000000"
//  3    "-123456789"         7           false        "-123456789.0000000"
//  4    "-123456789"         7           true         "-123456789.0000000"
//  5    "123456.789"         2           true             "123456.79"
//  6    "123456.789"         2           false            "123456.78"
//  7    "123456.789"         5           false            "123456.78900"
//  8    "123.456789"         1           false               "123.4"
//  9    "123.456789"         1           true                "123.5"
// 10    "-123.456789"        1           false              "-123.4"
// 11    "-123.456789"        1           true               "-123.5"
// 12    "123456.789"         0           true             "123457"
// 13    "-123456.789"        0           true            "-123457"
// 14    "123456.789"         0           false            "123456"
// 15    "-123456.789"        0           false           "-123456"
// 16    "123457"             1           false            "123457.0"
// 17    "123457"             1           true             "123457.0"
// 18    "-123457"            1           false           "-123457.0"
// 19    "-123457"            1           true            "-123457.0"
//
func (nStrDtoMolecule *numStrDtoMolecule) setPrecision(
	numStrFormatSpec *NumStrFmtSpecDto,
	signedNumStr string,
	precision uint,
	roundResult bool,
	ePrefix *ErrPrefixDto) (
	newNumStrDto NumStrDto,
	err error) {

	if nStrDtoMolecule.lock == nil {
		nStrDtoMolecule.lock = new(sync.Mutex)
	}

	nStrDtoMolecule.lock.Lock()

	defer nStrDtoMolecule.lock.Unlock()

	if ePrefix == nil {
		ePrefix = ErrPrefixDto{}.Ptr()
	}

	ePrefix.SetEPref("numStrDtoMolecule.setPrecision()")

	err = nil

	nStrDtoElectron := numStrDtoElectron{}

	newNumStrDto =
		nStrDtoElectron.newBaseZeroNumStrDto(0)

	if len(signedNumStr) == 0 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'signedNumStr' is INVALID!\n"+
			"'signedNumStr' is a zero length number string!\n",
			ePrefix.String())

		return newNumStrDto, err
	}

	if numStrFormatSpec == nil {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'numStrFormatSpec' is invalid!\n"+
			"numStrFormatSpec is a 'nil' pointer.\n",
			ePrefix.String())

		return newNumStrDto, err
	}

	err = numStrFormatSpec.IsValidInstanceError(
		ePrefix.XCtx("numStrFormatSpec"))

	if err != nil {
		return newNumStrDto, err
	}

	err = nStrDtoElectron.setFormatSpec(
		&newNumStrDto,
		numStrFormatSpec,
		ePrefix.XCtx("Setting 'newNumStrDto' numeric separators"))

	if err != nil {
		return newNumStrDto, err
	}

	var n0 NumStrDto

	n0, err = nStrDtoElectron.newEmptyNumStrDto(
		ePrefix.XCtx("Creating 'n0'"))

	if err != nil {
		return newNumStrDto, err
	}

	err = nStrDtoElectron.setFormatSpec(
		&n0,
		numStrFormatSpec,
		ePrefix.XCtx("Setting 'n0' Separators<-numSeparators"))

	if err != nil {
		return newNumStrDto, err
	}

	var n1 NumStrDto

	nStrDtoAtom := numStrDtoAtom{}

	n1,
		err = nStrDtoAtom.parseNumStr(
		signedNumStr,
		numStrFormatSpec,
		ePrefix.XCtx("n1=parse(signedNumStr)"))

	if err != nil {
		return newNumStrDto, err
	}

	var n2 NumStrDto

	n2, err = nStrDtoElectron.newEmptyNumStrDto(
		ePrefix.XCtx("Creating 'n2'"))

	if err != nil {
		return newNumStrDto, err
	}

	err = nStrDtoElectron.setFormatSpec(
		&n0,
		numStrFormatSpec,
		ePrefix.XCtx("Creating 'n0'"))

	if err != nil {
		return newNumStrDto, err
	}

	n2.signVal = n1.signVal
	n2.precision = precision

	err = nStrDtoElectron.setFormatSpec(
		&n2,
		numStrFormatSpec,
		ePrefix.XCtx("Setting 'n2' numeric separators"))

	if err != nil {
		return newNumStrDto, err
	}

	n2AbsIntRunes := make([]rune, 0, 40)
	n2AbsFracRunes := make([]rune, 0, 40)

	n2AbsIntRunes,
		err = nStrDtoElectron.getAbsIntRunes(
		&n2,
		ePrefix.XCtx("n2AbsIntRunes <- n2 "))

	if err != nil {
		return newNumStrDto, err
	}

	n2AbsFracRunes,
		err = nStrDtoElectron.getAbsFracRunes(
		&n2,
		ePrefix)

	if err != nil {
		return newNumStrDto, err
	}

	iSpecPrecision := int(precision)
	lenN1AbsAllNumRunes := len(n1.absAllNumRunes)
	n1AbsIntRunes := n1.GetAbsIntRunes()
	n1AbsFracRunes := n1.GetAbsFracRunes()
	lenN1AbsIntRunes := len(n1AbsIntRunes)
	lenN1AbsFracRunes := len(n1AbsFracRunes)
	totalRunes := 0

	if roundResult && lenN1AbsFracRunes > 0 &&
		iSpecPrecision < lenN1AbsFracRunes {

		absAllNumsToRound, isOk := big.NewInt(0).SetString(string(n1.absAllNumRunes), 10)

		if !isOk {

			err = fmt.Errorf("%v\n"+
				"Error: Failed to convert string to big.Int().\n"+
				"big.Int.SetString(n1.absAllNumRunes).\n"+
				"n1.absAllNumRunes='%v'\n",
				ePrefix.XCtxEmpty().String(),
				string(n1.absAllNumRunes))

			return newNumStrDto, err

		}

		bigDeltaPrecision := big.NewInt(int64(lenN1AbsFracRunes - iSpecPrecision - 1))
		base10 := big.NewInt(int64(10))
		roundUp5 := big.NewInt(int64(5))
		roundScaleFactor := big.NewInt(0).Exp(base10, bigDeltaPrecision, nil)
		roundUpNum := big.NewInt(0).Mul(roundUp5, roundScaleFactor)
		roundedAbsAllNums := big.NewInt(0).Add(absAllNumsToRound, roundUpNum)
		actualDeltaPrecision := big.NewInt(int64(lenN1AbsFracRunes - iSpecPrecision))
		actualDeltaScaleFactor := big.NewInt(0).Exp(base10, actualDeltaPrecision, nil)
		actualAbsAllNums := big.NewInt(0).Div(roundedAbsAllNums, actualDeltaScaleFactor)
		n1.absAllNumRunes = []rune{}
		n1AbsIntRunes = []rune{}
		n1AbsFracRunes = []rune{}
		n1.absAllNumRunes = []rune(actualAbsAllNums.String())
		lenN1AbsAllNumRunes = len(n1.absAllNumRunes)

		for i := 0; i < lenN1AbsAllNumRunes; i++ {

			if i < lenN1AbsIntRunes {
				n1AbsIntRunes = append(n1AbsIntRunes, n1.absAllNumRunes[i])
			} else {
				n1AbsFracRunes = append(n1AbsFracRunes, n1.absAllNumRunes[i])
			}
		}

		lenN1AbsIntRunes = len(n1AbsIntRunes)
		lenN1AbsFracRunes = len(n1AbsFracRunes)

		if lenN1AbsAllNumRunes != (lenN1AbsIntRunes + lenN1AbsFracRunes) {

			err = fmt.Errorf("%v\n"+
				"Error on Rounding. lenN1AbsAllNumRunes != "+
				"(lenN1AbsIntRunes + lenN1AbsFracRunes).\n"+
				"lenN1AbsAllNumRunes= '%v'\n"+
				"lenN1AbsIntRunes= '%v'\n"+
				"lenN1AbsFracRunes= '%v'\n",
				ePrefix.String(),
				lenN1AbsAllNumRunes,
				lenN1AbsIntRunes,
				lenN1AbsFracRunes)

			return newNumStrDto, err
		}
	}

	if lenN1AbsIntRunes == 0 {
		n2.absAllNumRunes = append(n2.absAllNumRunes, '0')
		n2AbsIntRunes = append(n2AbsIntRunes, '0')
	}

	totalRunes = lenN1AbsIntRunes + iSpecPrecision

	for i := 0; i < totalRunes; i++ {

		if i < lenN1AbsAllNumRunes {
			n2.absAllNumRunes = append(n2.absAllNumRunes, n1.absAllNumRunes[i])
		} else {
			n2.absAllNumRunes = append(n2.absAllNumRunes, '0')
		}

		if i < lenN1AbsIntRunes {

			n2AbsIntRunes = append(n2AbsIntRunes, n1.absAllNumRunes[i])

		} else {

			if i < lenN1AbsAllNumRunes {
				n2AbsFracRunes = append(n2AbsFracRunes, n1.absAllNumRunes[i])
			} else {
				n2AbsFracRunes = append(n2AbsFracRunes, '0')
			}
		}
	}

	newNumStrDto,
		err = nStrDtoElectron.copyOut(
		&n2,
		ePrefix.XCtx("n2->newNumStrDto "))

	if err != nil {
		return newNumStrDto, err
	}

	_,
		err = numStrDtoQuark{}.ptr().testNumStrDtoValidity(
		&newNumStrDto,
		ePrefix)

	return newNumStrDto, err

}

// shiftPrecisionLeft - Shifts the relative position of a decimal
// point within a number string. The position of the decimal point
// is shifted 'shiftPrecision' positions to the left of the current
// decimal point position.
//
// This is equivalent to: result = signedNumStr / 10^precision or
// signedNumStr divided by 10 raised to the power of precision.
//
// See the Example Usage section below.
//
// -----------------------------------------------------------------
//
// Input Parameters
//
//  numStrFormatSpec    *NumStrFmtSpecDto
//     - This object contains all the formatting specifications
//       required to format numeric values contained in type
//       NumStrDto.
//
//       The NumStrDto instance ('newNumStrDto') returned by this
//       method will be configured with this Number String Format
//       Specification.
//
//       type NumStrFmtSpecDto struct {
//         idNo           uint64
//         idString       string
//         description    string
//         tag            string
//         countryCulture FormatterCountry
//         absoluteValue  FormatterAbsoluteValue
//         currencyValue  FormatterCurrency
//         signedNumValue FormatterSignedNumber
//         sciNotation    FormatterSciNotation
//       }
//
//
//  signedNumStr        string
//     - A valid number string. The leading digit may optionally
//       be a '+' or '-' indicating numeric sign value. If '+'
//       or '-' characters are not present in the first character
//       position, the number is assumed to represent a positive
//       numeric value ('+'). In addition to leading plus or minus
//       characters, the number string may contain a decimal point
//       separating integer and fractional digits. All other
//       characters in this number string must be numeric digits.
//
//
//  shiftLeftPrecision  uint
//     - The number of digits by which the current decimal point
//       point position in the number string, 'signedNumStr' will
//       be shifted to the left.
//
//
//  ePrefix             *ErrPrefixDto
//     - This object encapsulates an error prefix string which is
//       included in all returned error messages. Usually, it
//       contains the names of the calling method or methods.
//
//       If error prefix information is NOT needed, set this
//       parameter to 'nil'.
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  newNumStrDto        NumStrDto
//     - If successful, the method returns the result of the Shift Left
//       precision operation in the form of a new 'NumStrDto' instance.
//
//
//  err                 error
//     - If this method completes successfully, the returned error
//       Type is set equal to 'nil'.
//
//       If errors are encountered during processing, the returned
//       error Type will encapsulate an error message. This
//       returned error message will incorporate the method chain
//       and text passed by input parameter, 'ePrefix'. The
//       'ePrefix' text will be attached to the beginning of the
//       error message.
//
//
// ------------------------------------------------------------------------
//
// Example Usage
//
//
//                                Shift-Left
//   signedNumStr    precision     Result
//   "123456.789"       3        "123.456789"
//   "123456.789"       2       "1234.56789"
//   "123456.789"       6          "0.123456789"
//   "123456789"        6        "123.456789"
//   "123"              5          "0.00123"
//    "0"               3          "0.000"
//    "0.000"           2          "0.00000"
//   "123456.789"       0     "123456.789"      - zero 'shiftPrecision' has no effect on
//                                                original number string
//  "-123456.789"       0       "-123.456789"
//  "-123456.789"       3       "-123.456789"
//  "-123456789"        6       "-123.456789"
//
func (nStrDtoMolecule *numStrDtoMolecule) shiftPrecisionLeft(
	numStrFormatSpec *NumStrFmtSpecDto,
	signedNumStr string,
	shiftLeftPrecision uint,
	ePrefix *ErrPrefixDto) (
	newNumStrDto NumStrDto,
	err error) {

	if nStrDtoMolecule.lock == nil {
		nStrDtoMolecule.lock = new(sync.Mutex)
	}

	nStrDtoMolecule.lock.Lock()

	defer nStrDtoMolecule.lock.Unlock()

	if ePrefix == nil {
		ePrefix = ErrPrefixDto{}.Ptr()
	}

	ePrefix.SetEPref(
		"numStrDtoMolecule.shiftPrecisionLeft()")

	err = nil

	nStrDtoElectron := numStrDtoElectron{}

	newNumStrDto =
		nStrDtoElectron.newBaseZeroNumStrDto(0)

	if len(signedNumStr) == 0 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'signedNumStr' is INVALID!\n"+
			"'signedNumStr' is a zero length number string!\n",
			ePrefix.String())

		return newNumStrDto, err
	}

	if numStrFormatSpec == nil {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'numStrFormatSpec' is invalid!\n"+
			"numStrFormatSpec is a 'nil' pointer.\n",
			ePrefix.String())

		return newNumStrDto, err
	}

	err = numStrFormatSpec.IsValidInstanceError(
		ePrefix.XCtx("numStrFormatSpec"))

	if err != nil {
		return newNumStrDto, err
	}

	err = nStrDtoElectron.setFormatSpec(
		&newNumStrDto,
		numStrFormatSpec,
		ePrefix.XCtx("Setting 'newNumStrDto' Format Spec"))

	if err != nil {
		return newNumStrDto, err
	}

	var n1 NumStrDto

	nStrDtoAtom := numStrDtoAtom{}

	n1,
		err = nStrDtoAtom.parseNumStr(
		signedNumStr,
		numStrFormatSpec,
		ePrefix.XCtx("signedNumStr -> n1"))

	if err != nil {
		return newNumStrDto, err
	}

	var n2 NumStrDto

	n2, err = nStrDtoElectron.newEmptyNumStrDto(
		ePrefix.XCtx("Creating 'n2'"))

	if err != nil {
		return newNumStrDto, err
	}

	err = nStrDtoElectron.setFormatSpec(
		&n2,
		numStrFormatSpec,
		ePrefix.XCtx("Setting 'n2' Format Spec"))

	if err != nil {
		return newNumStrDto, err
	}

	n2.signVal = n1.signVal

	n2.precision = shiftLeftPrecision + n1.precision

	iTotalSpecPrecision := int(n2.precision)
	lenAbsAllNumRunes := len(n1.absAllNumRunes)

	var lenAbsIntRunes, lenAbsFracRunes int

	lenAbsIntRunes =
		nStrDtoElectron.getAbsIntRunesLength(&n1)

	lenAbsFracRunes =
		nStrDtoElectron.getAbsFracRunesLength(&n1)

	var isZeroValue bool

	isZeroValue,
		err = nStrDtoElectron.isNumStrZeroValue(
		&n1,
		ePrefix.XCtx("n1"))

	if err != nil {
		return newNumStrDto, err
	}

	if isZeroValue {

		newNumStrDto =
			nStrDtoElectron.newBaseZeroNumStrDto(n2.precision)

		return newNumStrDto, err
	}

	if iTotalSpecPrecision == lenAbsAllNumRunes {

		n2.absAllNumRunes = append(n2.absAllNumRunes, '0')

	} else if iTotalSpecPrecision > lenAbsAllNumRunes {

		deltaPrecision := iTotalSpecPrecision - lenAbsAllNumRunes + 1

		for i := 0; i < deltaPrecision; i++ {
			n2.absAllNumRunes = append(n2.absAllNumRunes, '0')
		}

	}

	for j := 0; j < lenAbsAllNumRunes; j++ {
		n2.absAllNumRunes = append(n2.absAllNumRunes, n1.absAllNumRunes[j])
	}

	lenAbsAllNumRunes = len(n2.absAllNumRunes)
	lenAbsFracRunes = iTotalSpecPrecision
	lenAbsIntRunes = lenAbsAllNumRunes - lenAbsFracRunes

	if lenAbsIntRunes <= 0 {

		err = fmt.Errorf("%v\n"+
			"Calculated number of integer digits is less than or equal to ZERO.\n"+
			"lenAbsIntRunes= '%v'\n",
			ePrefix.String(),
			lenAbsIntRunes)

		return newNumStrDto, err
	}

	newNumStrDto,
		err = nStrDtoElectron.copyOut(
		&n2,
		ePrefix.XCtx("n2 -> newNumStrDto"))

	if err != nil {
		return newNumStrDto, err
	}

	_,
		err = numStrDtoQuark{}.ptr().testNumStrDtoValidity(
		&newNumStrDto,
		ePrefix.XCtx("Final validation 'newNumStrDto'"))

	return newNumStrDto, err
}

// shiftPrecisionRight - Shifts the relative precision of a decimal
// point with a number string. The position of the decimal point is
// shifted 'shiftRightPrecision' positions to the right of the
// original decimal point position.
//
// This is equivalent to: result = signedNumStr X 10^shiftRightPrecision
// or signedNumStr Multiplied by 10 raised to the power of
// 'shiftRightPrecision'.
//
// See the Example Usage section below.
//
// -----------------------------------------------------------------
//
// Input Parameters
//
//  numStrFormatSpec    *NumStrFmtSpecDto
//     - This object contains all the formatting specifications
//       required to format numeric values contained in type
//       NumStrDto.
//
//       The NumStrDto instance ('newNumStrDto') returned by this
//       method will be configured with this Number String Format
//       Specification.
//
//       type NumStrFmtSpecDto struct {
//         idNo           uint64
//         idString       string
//         description    string
//         tag            string
//         countryCulture FormatterCountry
//         absoluteValue  FormatterAbsoluteValue
//         currencyValue  FormatterCurrency
//         signedNumValue FormatterSignedNumber
//         sciNotation    FormatterSciNotation
//       }
//
//
//  signedNumStr        string
//     - A valid number string. The leading digit may optionally
//       be a '+' or '-' indicating numeric sign value. If '+'
//       or '-' characters are not present in the first character
//       position, the number is assumed to represent a positive
//       numeric value ('+'). In addition to leading plus or minus
//       characters, the number string may contain a decimal point
//       separating integer and fractional digits. All other
//       characters in this number string must be numeric digits.
//
//
//  shiftRightPrecision uint
//     - The number of digits by which the current decimal point
//       point position in the number string, 'signedNumStr' will
//       be shifted to the right.
//
//
//  ePrefix             *ErrPrefixDto
//     - This object encapsulates an error prefix string which is
//       included in all returned error messages. Usually, it
//       contains the names of the calling method or methods.
//
//       If error prefix information is NOT needed, set this
//       parameter to 'nil'.
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  newNumStrDto        NumStrDto
//     - If successful, the method returns the result of the Shift Left
//       precision operation in the form of a new 'NumStrDto' instance.
//
//
//  err                 error
//     - If this method completes successfully, the returned error
//       Type is set equal to 'nil'.
//
//       If errors are encountered during processing, the returned
//       error Type will encapsulate an error message. This
//       returned error message will incorporate the method chain
//       and text passed by input parameter, 'ePrefix'. The
//       'ePrefix' text will be attached to the beginning of the
//       error message.
//
//
// ------------------------------------------------------------------------
//
// Example Usage
//
// Notice that Zero 'shiftRightPrecision' has no effect on the original
// number string.
//
//   -------------------------------------------------------
//   signedNumStr   shiftRightPrecision       Result
//   -------------------------------------------------------
//   "123456.789"            3              "123456789"
//   "123456.789"            2              "12345678.9"
//   "123456.789"            6              "123456789000"
//   "123456789"             6              "123456789000000"
//   "123"                   5              "12300000"
//   "0"                     3              "0"
//   "123456.789"            0              "123456.789"
//  "-123456.789"            0             "-123456.789"
//  "-123456.789"            3             "-123456789"
//  "-123456789"             6             "-123456789000000"
//
func (nStrDtoMolecule *numStrDtoMolecule) shiftPrecisionRight(
	numStrFormatSpec *NumStrFmtSpecDto,
	signedNumStr string,
	shiftRightPrecision uint,
	ePrefix *ErrPrefixDto) (
	newNumStrDto NumStrDto,
	err error) {

	if nStrDtoMolecule.lock == nil {
		nStrDtoMolecule.lock = new(sync.Mutex)
	}

	nStrDtoMolecule.lock.Lock()

	defer nStrDtoMolecule.lock.Unlock()

	if ePrefix == nil {
		ePrefix = ErrPrefixDto{}.Ptr()
	}

	ePrefix.SetEPref(
		"numStrDtoMolecule.shiftPrecisionRight()")

	err = nil

	nStrDtoElectron := numStrDtoElectron{}

	newNumStrDto =
		nStrDtoElectron.newBaseZeroNumStrDto(0)

	if len(signedNumStr) == 0 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'signedNumStr' is INVALID!\n"+
			"'signedNumStr' is a zero length number string!\n",
			ePrefix.String())

		return newNumStrDto, err
	}

	if numStrFormatSpec == nil {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'numStrFormatSpec' is invalid!\n"+
			"numStrFormatSpec is a 'nil' pointer.\n",
			ePrefix.String())

		return newNumStrDto, err
	}

	err = numStrFormatSpec.IsValidInstanceError(
		ePrefix.XCtx("numStrFormatSpec"))

	if err != nil {
		return newNumStrDto, err
	}

	err = nStrDtoElectron.setFormatSpec(
		&newNumStrDto,
		numStrFormatSpec,
		ePrefix.XCtx("Setting 'newNumStrDto' Format Spec"))

	if err != nil {
		return newNumStrDto, err
	}

	var n1 NumStrDto

	nStrDtoAtom := numStrDtoAtom{}

	n1,
		err = nStrDtoAtom.parseNumStr(
		signedNumStr,
		numStrFormatSpec,
		ePrefix.XCtx("signedNumStr -> n1 "))

	if err != nil {
		return newNumStrDto, err
	}

	var n2 NumStrDto

	n2, err = nStrDtoElectron.newEmptyNumStrDto(
		ePrefix.XCtx("Creating n2"))

	if err != nil {
		return newNumStrDto, err
	}

	err = nStrDtoElectron.setFormatSpec(
		&n2,
		numStrFormatSpec,
		ePrefix.XCtx("Setting 'n2' Format Spec"))

	if err != nil {
		return newNumStrDto, err
	}

	iTotalSpecPrecision := 0
	iPrecision := int(shiftRightPrecision)
	iN1Precision := int(n1.precision)

	if iN1Precision > 0 && iPrecision < iN1Precision {
		iTotalSpecPrecision = iN1Precision - iPrecision
	} else {
		iTotalSpecPrecision = 0
	}

	n2.signVal = n1.signVal

	n2.precision = uint(iTotalSpecPrecision)

	lenAbsAllNumRunes := len(n1.absAllNumRunes)

	var isZeroValue bool

	isZeroValue,
		err = nStrDtoElectron.isNumStrZeroValue(
		&n1,
		ePrefix.XCtx("n1"))

	if err != nil {
		return newNumStrDto, err
	}

	if isZeroValue {

		newNumStrDto =
			nStrDtoElectron.newBaseZeroNumStrDto(n2.precision)

		return newNumStrDto, err
	}

	if int(shiftRightPrecision) > int(n1.precision) {

		for i := 0; i < lenAbsAllNumRunes; i++ {
			n2.absAllNumRunes = append(n2.absAllNumRunes, n1.absAllNumRunes[i])
		}

		deltaPrecision := int(shiftRightPrecision) - int(n1.precision)

		for i := 0; i < deltaPrecision; i++ {
			n2.absAllNumRunes = append(n2.absAllNumRunes, '0')
		}

	} else {

		for i := 0; i < lenAbsAllNumRunes; i++ {
			n2.absAllNumRunes = append(n2.absAllNumRunes, n1.absAllNumRunes[i])
		}

	}

	lenAbsAllNumRunes = len(n2.absAllNumRunes)
	lenAbsFracRunes := iTotalSpecPrecision
	lenAbsIntRunes := lenAbsAllNumRunes - lenAbsFracRunes

	if lenAbsIntRunes <= 0 {
		err = fmt.Errorf("%v\n"+
			"Calculated number of integer digits is less than or equal to ZERO.\n"+
			"lenAbsIntRunes= '%v'\n",
			ePrefix.String(),
			lenAbsIntRunes)

		return newNumStrDto, err
	}

	newNumStrDto,
		err = nStrDtoElectron.copyOut(
		&n2,
		ePrefix.XCtx("n2 -> newNumStrDto"))

	if err != nil {
		return newNumStrDto, err
	}

	_,
		err = numStrDtoQuark{}.ptr().testNumStrDtoValidity(
		&newNumStrDto,
		ePrefix.XCtx("Final validation 'newNumStrDto'"))

	return newNumStrDto, err
}
