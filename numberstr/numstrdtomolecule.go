package numberstr

import (
	"errors"
	"fmt"
	"math/big"
	"sync"
)

type numStrDtoMolecule struct {
	lock *sync.Mutex
}

// compareNumStrDtoSignedValues - compares the signed numeric values
// of two NumStrDto objects. The two NumStrDto objects to be
// compared are passed as input parameters 'n1Dto' and 'n2Dto'.
// 'n1Dto' is compared to 'n2Dto' and the comparison result is
// returned as an integer value.
//
//     Return Values:
//     -1 = n1Dto is less than n2Dto
//      0 = n1Dto is equal to n2Dto
//     +1 = n1Dto is greater than n2Dto
//
// Examples:
//                          Integer
//                         Comparison
//   n1Dto     n2Dto         Result
//  -------------------------------
//  -9691.23   91.245         -1
//  9691.23	   91.245          1
//    -5       82             -1
//     5        5              0
//
// -----------------------------------------------------------------
//
// Input Parameters
//
//  n1Dto               *NumStrDto
//     - A pointer to an instance of NumStrDto. This method WILL
//       NOT CHANGE data values of internal member variables to
//       achieve the method's objectives.
//
//       This numeric value of this NumStrDto instance will be
//       compared to that of the second input parameter, 'n2Dto'.
//
//       If NumStrDto instance 'n1Dto' is judged to be invalid an
//       error will be returned.
//
//
//  n2Dto               *NumStrDto
//     - A pointer to an instance of NumStrDto. This method WILL
//       NOT CHANGE data values of internal member variables to
//       achieve the method's objectives.
//
//       This numeric value of this NumStrDto instance will be
//       compared to that of the second input parameter, 'n2Dto'.
//
//       If NumStrDto instance 'n2Dto' is judged to be invalid an
//       error will be returned.
//
//
//  ePrefix             string
//     - This is an error prefix which is included in all returned
//       error messages. Usually, it contains the names of the calling
//       method or methods. Note: Be sure to leave a space at the end
//       of 'ePrefix'.
//
//
// -----------------------------------------------------------------
//
// Return Values
//
//  compareResult       int
//     - This comparison result is generated by comparing the numeric
//       values of input parameters 'n1Dto' and 'n2Dto'. If the method
//       completes successfully, this return parameter will be set to
//       one of three values thereby signaling the results of this
//       comparison.
//
//             'compareResult' Values
//         -1 = n1Dto is less than n2Dto
//          0 = n1Dto is equal to n2Dto
//         +1 = n1Dto is greater than n2Dto
//
//
//  err                error
//     - If this method completes successfully, the returned error Type
//       is set equal to 'nil'. If errors are encountered during processing,
//       the returned error Type will encapsulate an error message. Note
//       that this error message will incorporate the method chain and text
//       passed by input parameter, 'ePrefix'. Said text will be prefixed
//       to the beginning of the error message.
//
func (nStrDtoMolecule *numStrDtoMolecule) compareNumStrDtoSignedValues(
	n1Dto *NumStrDto,
	n2Dto *NumStrDto,
	ePrefix string) (
	compareResult int,
	err error) {

	if nStrDtoMolecule.lock == nil {
		nStrDtoMolecule.lock = new(sync.Mutex)
	}

	nStrDtoMolecule.lock.Lock()

	defer nStrDtoMolecule.lock.Unlock()

	ePrefix += "numStrDtoMolecule.compareNumStrDtoSignedValues() "

	err = nil
	compareResult = -99

	if n1Dto == nil {
		err = errors.New(ePrefix + "\n" +
			"Error: Input parameter 'n1Dto' has a 'nil' pointer!\n")

		return compareResult, err
	}

	if n2Dto == nil {
		err = errors.New(ePrefix + "\n" +
			"Error: Input parameter 'n1Dto' has a 'nil' pointer!\n")

		return compareResult, err
	}

	nStrDtoElectron := numStrDtoElectron{}

	_,
		err = nStrDtoElectron.testNumStrDtoValidity(
		n1Dto,
		ePrefix+"Testing 'n1Dto' Validity ")

	if err != nil {
		return compareResult, err
	}

	_,
		err = nStrDtoElectron.testNumStrDtoValidity(
		n2Dto,
		ePrefix+"Testing 'n2Dto' Validity ")

	if err != nil {
		return compareResult, err
	}

	nStrDtoAtom := numStrDtoAtom{}

	var cmpAbs int

	cmpAbs,
		err = nStrDtoAtom.compareNumStrDtoAbsoluteValues(
		n1Dto,
		n2Dto,
		"Comparing 'n1Dto' to 'n2Dto' ")

	if err != nil {
		return compareResult, err

	}

	if cmpAbs == 0 {

		if n1Dto.signVal == n2Dto.signVal {

			compareResult = 0

		} else {

			// n1Dto.signVal != n2Dto.signVal
			if n1Dto.signVal == 1 {

				compareResult = 1

			} else {

				// n2Dto.signVal must == 1
				compareResult = -1

			}

		}

		return compareResult, err
	}

	if cmpAbs == 1 {

		if n1Dto.signVal == n2Dto.signVal {

			if n1Dto.signVal == 1 {

				compareResult = 1

			} else {

				// must be n1Dto.signVal == n2Dto.signVal && n1Dto.signVal == -1
				compareResult = -1

			}

			return compareResult, err
		}

		// must be n1Dto.signVal != n2Dto.signVal
		if n1Dto.signVal == 1 {

			compareResult = 1

		} else {

			// must be n2Dto.signVal == 1
			compareResult = -1

		}

		return compareResult, err
	}

	// Must Be cmpAbs == -1

	if n2Dto.signVal == n1Dto.signVal {

		if n2Dto.signVal == 1 {

			// n1Dto.signVal && n2Dto.signVal must equal 1
			compareResult = -1

		} else {

			// n1Dto.signVal && n2Dto.signVal must equal -1
			compareResult = 1

		}

		return compareResult, err
	}

	// Must Be cmpAbs == -1
	// Must Be n2Dto.signVal != n1Dto.signVal

	if n2Dto.signVal == -1 {

		compareResult = 1

	} else {

		// must be n2Dto.signVal == 1
		compareResult = -1

	}

	return compareResult, err
}

// FormatForMathOps - receives two NumStrDto objects and converts their strings
// such that both have the same number of integer and fractional digits. This will
// facilitate the performance of string based math operations such as addition and
// subtraction.
//
// The return values represent the formatted NumStrDto objects. The first NumStrDto
// returned always contains the larger absolute value. The second NumStrDto always
// contains the absolute numeric value which is less than or equal to the first
// NumStrDto object returned.
//
// The third parameter returned by this method is an int which will always be set to
// 1 or 0. 1 indicates that the absolute value of the first NumStrDto returned by
// this method is greater than the second NumStrDto returned by this method. If
// the int value returned is zero, it signals that the absolute values
// (not the signed values) of both returned NumStrDto objects are equal.
//
//
// ------------------------------------------------------------------------
//
// Input Parameters
//
//  n1Dto           *NumStrDto
//     - A pointer to an instance of NumStrDto. This method will
//       NOT change the values of internal member variables to achieve
//       the method's objectives.
//
//
//  n2Dto           *NumStrDto
//     - A pointer to a second instance of NumStrDto. This method will
//       NOT change the values of internal member variables to achieve
//       the method's objectives.
//
//
//  ePrefix             string
//     - A string consisting of the method chain used to call
//       this method. In case of error, this text string is included
//       in the error message. Note: Be sure to leave a space at the
//       end of 'ePrefix'.
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  n1DtoOut            NumStrDto
//     - This numeric value will always be greater than or equal to that
//       of n2DtoOut.
//
//
//  n2DtoOut            NumStrDto
//     - This numeric value will always be less than or equal to that
//       of n1DtoOut.
//
//
//  compare             int
//     - Set to one of two values: +1 or 0.
//
//       Plus 1 (+1) signals that the absolute value of 'n1DtoOut' is
//       greater than 'n2DtoOut'
//
//       Zero (0) signals that the absolute values (not the signed values)
//       of both 'n1DtoOut' and 'n2DtoOut' are equal.
//
//
//  isOrderReversed     bool
//     - If this returned boolean value is set to 'true', it signals that
//       returned parameter 'n1DtoOut' is equal to input parameter 'n2Dto'
//       and returned 'n2DtoOut' is equal to input parameter 'n1Dto'.
//
//       If 'isOrderReversed' is set to 'false',it signals that returned
//       parameter 'n1DtoOut' is equal to input parameter 'n1Dto'
//       and returned 'n2DtoOut' is equal to input parameter 'n2Dto'.
//
//
//  err                 error
//     - If this method completes successfully, the returned error Type is set
//       equal to 'nil'. If errors are encountered during processing, the
//       returned error Type will encapsulate an error message. Note this
//       error message will incorporate the method chain and text passed by
//       input parameter, 'ePrefix'.
//
func (nStrDtoMolecule *numStrDtoMolecule) formatForMathOps(
	n1Dto *NumStrDto,
	n2Dto *NumStrDto,
	ePrefix string) (
	n1DtoOut NumStrDto,
	n2DtoOut NumStrDto,
	compare int,
	isOrderReversed bool,
	err error) {

	if nStrDtoMolecule.lock == nil {
		nStrDtoMolecule.lock = new(sync.Mutex)
	}

	nStrDtoMolecule.lock.Lock()

	defer nStrDtoMolecule.lock.Unlock()

	ePrefix += "numStrDtoMolecule.formatForMathOps() "

	nStrDtoElectron := numStrDtoElectron{}
	compare = -99
	isOrderReversed = false
	err = nil

	n1DtoOut = nStrDtoElectron.newBaseZeroNumStrDto(
		0)

	n2DtoOut = nStrDtoElectron.newBaseZeroNumStrDto(
		0)

	if n1Dto == nil {
		err = errors.New(ePrefix +
			"\nInput parameter 'n1Dto' is INVALID!\n" +
			"n1Dto = nil pointer!\n")
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	if n2Dto == nil {
		err = errors.New(ePrefix +
			"\nInput parameter 'n2Dto' is INVALID!\n" +
			"n2Dto = nil pointer!\n")
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	lenN1AllRunes := 0
	lenN1IntRunes := 0
	lenN1FracRunes := 0
	lenN2AllRunes := 0
	lenN2IntRunes := 0
	lenN2FracRunes := 0

	_,
		err =
		nStrDtoElectron.testNumStrDtoValidity(
			n1Dto,
			ePrefix+"n1Dto ")

	if err != nil {
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	_,
		err =
		nStrDtoElectron.testNumStrDtoValidity(
			n2Dto,
			ePrefix+"n2Dto ")

	if err != nil {
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	nStrDtoAtom := numStrDtoAtom{}

	compare,
		err =
		nStrDtoAtom.compareNumStrDtoAbsoluteValues(
			n1Dto,
			n2Dto,
			ePrefix)

	if err != nil {
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	if compare == 1 {

		compare = 1

		n1DtoOut,
			err = nStrDtoElectron.copyOut(
			n1Dto,
			ePrefix)

		if err != nil {
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

		n2DtoOut,
			err = nStrDtoElectron.copyOut(
			n2Dto,
			ePrefix)

		if err != nil {
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

	} else if compare == -1 {

		n1DtoOut,
			err = nStrDtoElectron.copyOut(
			n2Dto,
			ePrefix)

		if err != nil {
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

		n2DtoOut,
			err = nStrDtoElectron.copyOut(
			n1Dto,
			ePrefix)

		if err != nil {
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

		isOrderReversed = true
		compare = 1

	} else {
		// compare must be zero

		compare = 0

		n1DtoOut,
			err = nStrDtoElectron.copyOut(
			n1Dto,
			ePrefix)

		if err != nil {
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

		n2DtoOut,
			err = nStrDtoElectron.copyOut(
			n2Dto,
			ePrefix)

		if err != nil {
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

	}

	var n1DtoOutAbsIntRunes, n1DtoOutAbsFracRunes,
		n2DtoOutAbsIntRunes, n2DtoOutAbsFracRunes []rune

	n1DtoOutAbsIntRunes,
		err =
		nStrDtoElectron.getAbsIntRunes(
			&n1DtoOut,
			ePrefix+"n1DtoOut ")

	if err != nil {
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	n1DtoOutAbsFracRunes,
		err =
		nStrDtoElectron.getAbsFracRunes(
			&n1DtoOut,
			ePrefix+"n1DtoOut ")

	if err != nil {
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	n2DtoOutAbsIntRunes,
		err =
		nStrDtoElectron.getAbsIntRunes(
			&n2DtoOut,
			ePrefix+"n2DtoOut ")

	if err != nil {
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	n2DtoOutAbsFracRunes,
		err =
		nStrDtoElectron.getAbsFracRunes(
			&n2DtoOut,
			ePrefix+"n2DtoOut ")

	if err != nil {
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	if n1DtoOut.precision > n2DtoOut.precision {

		deltaPrecision := n1DtoOut.precision - n2DtoOut.precision

		for i := uint(0); i < deltaPrecision; i++ {
			n2DtoOut.absAllNumRunes = append(n2DtoOut.absAllNumRunes, '0')
			n2DtoOutAbsFracRunes = append(n2DtoOutAbsFracRunes, '0')
		}

		lenN2AllRunes = len(n2DtoOut.absAllNumRunes)
		lenN2IntRunes = len(n2DtoOutAbsIntRunes)
		lenN2FracRunes = len(n2DtoOutAbsFracRunes)

		n2DtoOut.precision = n1DtoOut.precision
		_,
			err =
			nStrDtoElectron.testNumStrDtoValidity(
				&n2DtoOut,
				ePrefix+"n2DtoOut ")

		if err != nil {
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

		lenN1AllRunes = len(n1DtoOut.absAllNumRunes)
		lenN1IntRunes = len(n1DtoOutAbsIntRunes)
		lenN1FracRunes = len(n1DtoOutAbsFracRunes)

	} else if n1DtoOut.precision < n2DtoOut.precision {

		deltaPrecision := n2DtoOut.precision - n1DtoOut.precision

		for i := uint(0); i < deltaPrecision; i++ {
			n1DtoOut.absAllNumRunes = append(n1DtoOut.absAllNumRunes, '0')
			n1DtoOutAbsFracRunes = append(n1DtoOutAbsFracRunes, '0')
		}

		lenN1AllRunes = len(n1DtoOut.absAllNumRunes)
		lenN1IntRunes = len(n1DtoOutAbsIntRunes)
		lenN1FracRunes = len(n1DtoOutAbsFracRunes)

		n1DtoOut.precision = n2DtoOut.precision

		_,
			err =
			nStrDtoElectron.testNumStrDtoValidity(
				&n1DtoOut,
				ePrefix+"n1DtoOut ")

		if err != nil {
			n1DtoOut = NumStrDto{}
			n2DtoOut = NumStrDto{}
			compare = -99
			isOrderReversed = false
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

		lenN2AllRunes = len(n2DtoOut.absAllNumRunes)
		lenN2IntRunes = len(n2DtoOutAbsIntRunes)
		lenN2FracRunes = len(n2DtoOutAbsFracRunes)

	} else {
		// n1DtoOut.precision == n2DtoOut.precision

		lenN1AllRunes = len(n1DtoOut.absAllNumRunes)
		lenN1IntRunes = len(n1DtoOutAbsIntRunes)
		lenN1FracRunes = len(n1DtoOutAbsFracRunes)

		lenN2AllRunes = len(n2DtoOut.absAllNumRunes)
		lenN2IntRunes = len(n2DtoOutAbsIntRunes)
		lenN2FracRunes = len(n2DtoOutAbsFracRunes)

	}

	if lenN2IntRunes > lenN1IntRunes {

		var absAllRunes []rune
		var absIntRunes []rune
		deltaRunes := lenN2IntRunes - lenN1IntRunes
		for i := 0; i < deltaRunes; i++ {
			absAllRunes = append(absAllRunes, '0')
			absIntRunes = append(absIntRunes, '0')
		}

		for j := 0; j < lenN1AllRunes; j++ {
			absAllRunes = append(absAllRunes, n1DtoOut.absAllNumRunes[j])

			if j < lenN1IntRunes {
				absIntRunes = append(absIntRunes, n1DtoOutAbsIntRunes[j])
			}

		}

		n1DtoOut.absAllNumRunes = absAllRunes
		n1DtoOutAbsIntRunes = absIntRunes
		lenN1AllRunes = len(n1DtoOut.absAllNumRunes)
		lenN1IntRunes = len(n1DtoOutAbsIntRunes)

		_,
			err =
			nStrDtoElectron.testNumStrDtoValidity(
				&n1DtoOut,
				ePrefix+"n1DtoOut #2 ")

		if err != nil {
			n1DtoOut = NumStrDto{}
			n2DtoOut = NumStrDto{}
			compare = -99
			isOrderReversed = false
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

	} else if lenN1IntRunes > lenN2IntRunes {

		var absAllRunes []rune
		var absIntRunes []rune
		deltaRunes := lenN1IntRunes - lenN2IntRunes
		for i := 0; i < deltaRunes; i++ {
			absAllRunes = append(absAllRunes, '0')
			absIntRunes = append(absIntRunes, '0')
		}

		for j := 0; j < lenN2AllRunes; j++ {
			absAllRunes = append(absAllRunes, n2DtoOut.absAllNumRunes[j])

			if j < lenN2IntRunes {
				absIntRunes = append(absIntRunes, n2DtoOutAbsIntRunes[j])
			}

		}

		n2DtoOut.absAllNumRunes = absAllRunes
		n2DtoOutAbsIntRunes = absIntRunes
		lenN2AllRunes = len(n2DtoOut.absAllNumRunes)
		lenN2IntRunes = len(n2DtoOutAbsIntRunes)

		_,
			err =
			nStrDtoElectron.testNumStrDtoValidity(
				&n2DtoOut,
				ePrefix+"n2DtoOut #2 ")

		if err != nil {
			return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
		}

	}

	if lenN1AllRunes != lenN2AllRunes {
		err = fmt.Errorf("FormatForMathOps() - n1 and n2 AllNumRune arrays are NOT equal in length. "+
			"n1 length= '%v' n2 length= '%v'", lenN1AllRunes, lenN2AllRunes)

		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	if lenN1IntRunes != lenN2IntRunes {
		err = fmt.Errorf("FormatForMathOps() - n1 and n2 IntRunes arrays are NOT equal in length. "+
			"n1 length= '%v' n2 length= '%v'", lenN1IntRunes, lenN2IntRunes)

		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	if lenN1FracRunes != lenN2FracRunes {
		err = fmt.Errorf("FormatForMathOps() - n1 and n2 FracRunes arrays are NOT equal in length. "+
			"n1 length= '%v' n2 length= '%v'", lenN1FracRunes, lenN2FracRunes)

		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	if n1DtoOut.precision != n2DtoOut.precision {
		err = fmt.Errorf("FormatForMathOps() - n1 and n2 FracRunes arrays are NOT equal in length. "+
			"n1 length= '%v' n2 length= '%v'", lenN1FracRunes, lenN2FracRunes)

		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}

	_,
		err =
		nStrDtoElectron.testNumStrDtoValidity(
			&n1DtoOut,
			ePrefix+"n1DtoOut #3 ")

	if err != nil {
		return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
	}
	_,
		err =
		nStrDtoElectron.testNumStrDtoValidity(
			&n2DtoOut,
			ePrefix+"n2DtoOut #3 ")

	if err != nil {
		n1DtoOut = NumStrDto{}
		n2DtoOut = NumStrDto{}
		compare = -99
		isOrderReversed = false
	}

	return n1DtoOut, n2DtoOut, compare, isOrderReversed, err
}

// getNumStr - returns the numeric value of the current NumStrDto
// instance as a signed number string. The resulting number string
// will NOT contain a currency symbol or thousands separators. It
// will contain a decimal separator and fractional digits if such
// fractional digits exist.
//
// Note: If the current NumStrDto is invalid, this method will return
// an error.
//
// Examples:
//   123456.78
//  -123456.78
//
//
// ------------------------------------------------------------------------
//
// Input Parameters
//
//  numStrDto           *NumStrDto
//     - A pointer to an instance of NumStrDto. This method will
//       NOT change the values of internal member variables to achieve
//       the method's objectives. This NumStrDto will supply the
//       numeric value which will be used to create the returned
//       number string.
//
//
//  ePrefix             string
//     - A string consisting of the method chain used to call
//       this method. In case of error, this text string is included
//       in the error message. Note: Be sure to leave a space at the
//       end of 'ePrefix'.
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//
//  numStr              string
//     - If this method completes successfully, the numeric value of the
//       current NumStrDto instance will be returned as a plain number
//       string with no thousands separator or currency symbol. Negative
//       values will be formatted with a leading minus sign.
//
//       Examples:
//         123456.78
//        -123456.78
//
//
//  err                 error
//     - If this method completes successfully, the returned error Type is set
//       equal to 'nil'. If errors are encountered during processing, the
//       returned error Type will encapsulate an error message. Note this
//       error message will incorporate the method chain and text passed by
//       input parameter, 'ePrefix'.
//
func (nStrDtoMolecule *numStrDtoMolecule) getNumStr(
	numStrDto *NumStrDto,
	ePrefix string) (
	numStr string,
	err error) {

	if nStrDtoMolecule.lock == nil {
		nStrDtoMolecule.lock = new(sync.Mutex)
	}

	nStrDtoMolecule.lock.Lock()

	defer nStrDtoMolecule.lock.Unlock()

	ePrefix += "numStrDtoMolecule.getNumStr() "

	numStr = ""
	err = nil

	if numStrDto == nil {
		err = errors.New(ePrefix +
			"\nInput parameter 'numStrDto' is INVALID!\n" +
			"numStrDto = nil pointer!\n")
		return numStr, err
	}

	nStrDtoElectron := numStrDtoElectron{}

	_,
		err = nStrDtoElectron.testNumStrDtoValidity(
		numStrDto,
		ePrefix+"Testing Validity of 'numStrDto' ")

	if err != nil {
		return numStr, err
	}

	nStrDtoAtom := numStrDtoAtom{}

	numStr,
		err = nStrDtoAtom.formatNumStr(
		numStrDto,
		LEADMINUSNEGVALFMTMODE,
		ePrefix)

	return numStr, err
}

//
// ------------------------------------------------------------------------
//
// Input Parameters
//
//  numStrDto           *NumStrDto
//     - A pointer to an instance of NumStrDto. This method will
//       NOT change the values of internal member variables to achieve
//       the method's objectives. This NumStrDto will supply the
//       numeric value which will be used to create the returned
//       number string.
//
//
//  ePrefix             string
//     - A string consisting of the method chain used to call
//       this method. In case of error, this text string is included
//       in the error message. Note: Be sure to leave a space at the
//       end of 'ePrefix'.
//
//
func (nStrDtoMolecule *numStrDtoMolecule) getSignedBigIntNum(
	numStrDto *NumStrDto,
	ePrefix string) (
	bigIntNum *big.Int,
	err error) {

	if nStrDtoMolecule.lock == nil {
		nStrDtoMolecule.lock = new(sync.Mutex)
	}

	nStrDtoMolecule.lock.Lock()

	defer nStrDtoMolecule.lock.Unlock()

	ePrefix += "numStrDtoMolecule.getSignedBigIntNum() "

	err = nil
	bigIntNum = big.NewInt(0)

	if numStrDto == nil {
		err = errors.New(ePrefix +
			"\nInput parameter 'numStrDto' is INVALID!\n" +
			"numStrDto = nil pointer!\n")
		return bigIntNum, err
	}

	nStrDtoElectron := numStrDtoElectron{}

	_,
		err = nStrDtoElectron.testNumStrDtoValidity(
		numStrDto,
		ePrefix+"Testing Validity of 'numStrDto' ")

	if err != nil {
		return bigIntNum, err
	}

	bigIntAbsVal := big.NewInt(0)

	nStrDtoAtom := numStrDtoAtom{}

	bigIntAbsVal,
		err = nStrDtoAtom.getAbsoluteBigInt(
		numStrDto,
		ePrefix+"numStrDto ")

	if err != nil {
		return bigIntNum, err
	}

	if numStrDto.signVal < 0 {
		bigIntNum.Set(big.NewInt(0).Neg(bigIntAbsVal))
	} else {
		bigIntNum.Set(bigIntAbsVal)
	}

	return bigIntNum, err
}

// SetPrecision - parses the incoming number string and applies the designated 'precision'.
// 'precision' determines the number of digits to the right of the decimal place. The boolean
// parameter 'roundResult' is used to apply rounding in those cases where 'precision' dictates
// a reduction in the number of digits to the right of the decimal place. See 'Examples' below.
//
//
// --------------------------------------------------------------------------------------------------
//
// Input Parameters
//
//  numSeparators       NumericSeparatorDto
//     - The numeric separator values contained in this input
//       parameter will be copied to the returned input parameter
//       'newNumStrDto', a newly created instance of NumStrDto.
//
//       The data fields included in the NumericSeparatorDto are
//       listed as follows:
//
//          type NumericSeparatorDto struct {
//
//            DecimalSeparator   rune // Character used to separate
//                                    //  integer and fractional digits ('.')
//
//            ThousandsSeparator rune // Character used to separate thousands
//                                    //  (1,000,000,000
//
//            CurrencySymbol     rune // Currency Symbol
//          }
//
//       If any of the data fields in this passed structure
//       'customSeparators' are set to zero ('0'), they will
//       be reset to USA default values. USA default numeric
//       separators are listed as follows:
//
//             Currency Symbol: '$'
//         Thousands Separator: ','
//           Decimal Separator: '.'
//
//
//  signedNumStr        string
//     - A valid number string
//
//
//  precision           uint
//     - The 'precision' values designates the number of places to the right of the
//       decimal point which will be realized upon completion of this operation.
//
//
//  roundResult         bool
//     - If the 'precision' value is less than the current number of places to the
//       right of the decimal point, this method will truncate the existing fractional
//       digits. If 'roundResult' is set to true, this truncation operation will
//       include rounding the last digit.
//
//
//  ePrefix             string
//     - Error Prefix. A string consisting of the method chain used
//       to call this method. In case of error, this text string is
//       included in the error message. Note: Be sure to leave a space
//       at the end of 'ePrefix'. If no Error Prefix is desired, simply
//       provide an empty string for this parameter.
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  newNumStrDto        NumStrDto
//     - A new instance of NumStrDto encapsulating the numeric value
//       calculated from the input parameters.
//
//
//  err                error
//     - If successful the returned error Type is set equal to 'nil'.
//       If errors are encountered during processing, the returned
//       error Type will encapsulate an error message. Note this error
//       message will incorporate the method chain and text passed
//       by input parameter, 'ePrefix'.
//
//
// ------------------------------------------------------------------------
//
// Example Usage
//
//       ------------ Input Parameters -----------      ---- Result --------
// Test
//  No   signedNumStr      precision   roundResult
//  ---- ------------------------------------------------------------------
//  1    "123456789"          7           false         "123456789.0000000"
//  2    "123456789"          7           true          "123456789.0000000"
//  3    "-123456789"         7           false        "-123456789.0000000"
//  4    "-123456789"         7           true         "-123456789.0000000"
//  5    "123456.789"         2           true             "123456.79"
//  6    "123456.789"         2           false            "123456.78"
//  7    "123456.789"         5           false            "123456.78900"
//  8    "123.456789"         1           false               "123.4"
//  9    "123.456789"         1           true                "123.5"
// 10    "-123.456789"        1           false              "-123.4"
// 11    "-123.456789"        1           true               "-123.5"
// 12    "123456.789"         0           true             "123457"
// 13    "-123456.789"        0           true            "-123457"
// 14    "123456.789"         0           false            "123456"
// 15    "-123456.789"        0           false           "-123456"
// 16    "123457"             1           false            "123457.0"
// 17    "123457"             1           true             "123457.0"
// 18    "-123457"            1           false           "-123457.0"
// 19    "-123457"            1           true            "-123457.0"
//
func (nStrDtoMolecule *numStrDtoMolecule) setPrecision(
	numSeparators NumericSeparatorDto,
	signedNumStr string,
	precision uint,
	roundResult bool,
	ePrefix string) (
	newNumStrDto NumStrDto,
	err error) {

	if nStrDtoMolecule.lock == nil {
		nStrDtoMolecule.lock = new(sync.Mutex)
	}

	nStrDtoMolecule.lock.Lock()

	defer nStrDtoMolecule.lock.Unlock()

	ePrefix += "numStrDtoMolecule.setPrecision() "

	err = nil

	nStrDtoElectron := numStrDtoElectron{}

	newNumStrDto =
		nStrDtoElectron.newBaseZeroNumStrDto(0)

	if len(signedNumStr) == 0 {
		err = errors.New(ePrefix + "\n" +
			"Error: Input parameter 'signedNumStr' is INVALID!\n" +
			"'signedNumStr' is a zero length number string!\n")

		return newNumStrDto, err
	}

	// Set defaults for thousands separators,
	// decimal separators and currency Symbols
	numSeparators.SetToUSADefaultsIfEmpty()

	err = nStrDtoElectron.setNumericSeparatorsDto(
		&newNumStrDto,
		numSeparators,
		ePrefix+"Setting 'newNumStrDto' numeric separators ")

	if err != nil {
		return newNumStrDto, err
	}

	n0 := NumStrDto{}.New()

	err = nStrDtoElectron.setNumericSeparatorsDto(
		&n0,
		numSeparators,
		ePrefix+"Setting 'n0' numeric separators ")

	if err != nil {
		return newNumStrDto, err
	}

	var n1 NumStrDto

	nStrDtoAtom := numStrDtoAtom{}

	n1,
		err = nStrDtoAtom.parseNumStr(
		signedNumStr,
		numSeparators,
		ePrefix+"n1 ")

	if err != nil {
		return newNumStrDto, err
	}

	n2 := NumStrDto{}.New()

	n2.signVal = n1.signVal
	n2.precision = precision

	err = nStrDtoElectron.setNumericSeparatorsDto(
		&n2,
		numSeparators,
		ePrefix+"Setting 'n2' numeric separators ")

	if err != nil {
		return newNumStrDto, err
	}

	n2AbsIntRunes := make([]rune, 0, 40)
	n2AbsFracRunes := make([]rune, 0, 40)

	n2AbsIntRunes,
		err = nStrDtoElectron.getAbsIntRunes(
		&n2,
		ePrefix+"n2 ")

	if err != nil {
		return newNumStrDto, err
	}

	n2AbsFracRunes,
		err = nStrDtoElectron.getAbsFracRunes(
		&n2,
		ePrefix)

	if err != nil {
		return newNumStrDto, err
	}

	iSpecPrecision := int(precision)
	lenN1AbsAllNumRunes := len(n1.absAllNumRunes)
	n1AbsIntRunes := n1.GetAbsIntRunes()
	n1AbsFracRunes := n1.GetAbsFracRunes()
	lenN1AbsIntRunes := len(n1AbsIntRunes)
	lenN1AbsFracRunes := len(n1AbsFracRunes)
	totalRunes := 0

	if roundResult && lenN1AbsFracRunes > 0 &&
		iSpecPrecision < lenN1AbsFracRunes {

		absAllNumsToRound, isOk := big.NewInt(0).SetString(string(n1.absAllNumRunes), 10)

		if !isOk {
			err = fmt.Errorf(ePrefix+"\n"+
				"Error: Failed to convert string to big.Int(). "+
				"big.Int.SetString(n1.absAllNumRunes). n1.absAllNumRunes='%v' ",
				string(n1.absAllNumRunes))

			return newNumStrDto, err

		}

		bigDeltaPrecision := big.NewInt(int64(lenN1AbsFracRunes - iSpecPrecision - 1))
		base10 := big.NewInt(int64(10))
		roundUp5 := big.NewInt(int64(5))
		roundScaleFactor := big.NewInt(0).Exp(base10, bigDeltaPrecision, nil)
		roundUpNum := big.NewInt(0).Mul(roundUp5, roundScaleFactor)
		roundedAbsAllNums := big.NewInt(0).Add(absAllNumsToRound, roundUpNum)
		actualDeltaPrecision := big.NewInt(int64(lenN1AbsFracRunes - iSpecPrecision))
		actualDeltaScaleFactor := big.NewInt(0).Exp(base10, actualDeltaPrecision, nil)
		actualAbsAllNums := big.NewInt(0).Div(roundedAbsAllNums, actualDeltaScaleFactor)
		n1.absAllNumRunes = []rune{}
		n1AbsIntRunes = []rune{}
		n1AbsFracRunes = []rune{}
		n1.absAllNumRunes = []rune(actualAbsAllNums.String())
		lenN1AbsAllNumRunes = len(n1.absAllNumRunes)

		for i := 0; i < lenN1AbsAllNumRunes; i++ {

			if i < lenN1AbsIntRunes {
				n1AbsIntRunes = append(n1AbsIntRunes, n1.absAllNumRunes[i])
			} else {
				n1AbsFracRunes = append(n1AbsFracRunes, n1.absAllNumRunes[i])
			}
		}

		lenN1AbsIntRunes = len(n1AbsIntRunes)
		lenN1AbsFracRunes = len(n1AbsFracRunes)

		if lenN1AbsAllNumRunes != (lenN1AbsIntRunes + lenN1AbsFracRunes) {

			err = fmt.Errorf(ePrefix+"Error on Rounding. lenN1AbsAllNumRunes != "+
				"(lenN1AbsIntRunes + lenN1AbsFracRunes). lenN1AbsAllNumRunes= '%v' "+
				"lenN1AbsIntRunes= '%v' lenN1AbsFracRunes= '%v'",
				lenN1AbsAllNumRunes, lenN1AbsIntRunes, lenN1AbsFracRunes)
			return newNumStrDto, err
		}

	}

	if lenN1AbsIntRunes == 0 {
		n2.absAllNumRunes = append(n2.absAllNumRunes, '0')
		n2AbsIntRunes = append(n2AbsIntRunes, '0')
	}

	totalRunes = lenN1AbsIntRunes + iSpecPrecision

	for i := 0; i < totalRunes; i++ {

		if i < lenN1AbsAllNumRunes {
			n2.absAllNumRunes = append(n2.absAllNumRunes, n1.absAllNumRunes[i])
		} else {
			n2.absAllNumRunes = append(n2.absAllNumRunes, '0')
		}

		if i < lenN1AbsIntRunes {

			n2AbsIntRunes = append(n2AbsIntRunes, n1.absAllNumRunes[i])

		} else {

			if i < lenN1AbsAllNumRunes {
				n2AbsFracRunes = append(n2AbsFracRunes, n1.absAllNumRunes[i])
			} else {
				n2AbsFracRunes = append(n2AbsFracRunes, '0')
			}
		}
	}

	newNumStrDto,
		err = nStrDtoElectron.copyOut(
		&n2,
		ePrefix+"n2->newNumStrDto ")

	if err != nil {
		return newNumStrDto, err
	}

	_,
		err = nStrDtoElectron.testNumStrDtoValidity(
		&newNumStrDto,
		ePrefix)

	return newNumStrDto, err

}

// shiftPrecisionLeft - Shifts the relative position of a decimal
// point within a number string. The position of the decimal point
// is shifted 'shiftPrecision' positions to the left of the current
// decimal point position.
//
// This is equivalent to: result = signedNumStr / 10^precision or
// signedNumStr divided by 10 raised to the power of precision.
//
// See the Example Usage section below.
//
// -----------------------------------------------------------------
//
// Input Parameters
//
//  numSeparators       NumericSeparatorDto
//     - The numeric separator values contained in this input
//       parameter will be copied to the returned input parameter
//       'newNumStrDto', a newly created instance of NumStrDto.
//
//       The data fields included in the NumericSeparatorDto are
//       listed as follows:
//
//          type NumericSeparatorDto struct {
//
//            DecimalSeparator   rune // Character used to separate
//                                    //  integer and fractional digits ('.')
//
//            ThousandsSeparator rune // Character used to separate thousands
//                                    //  (1,000,000,000
//
//            CurrencySymbol     rune // Currency Symbol
//          }
//
//       If any of the data fields in this passed structure 'customSeparators'
//       are set to zero ('0'), they will be reset to USA default values.
//       USA default numeric separators are listed as follows:
//             Currency Symbol: '$'
//         Thousands Separator: ','
//           Decimal Separator: '.'
//
//
//  signedNumStr        string
//     - A valid number string. The leading digit may optionally
//       be a '+' or '-' indicating numeric sign value. If '+'
//       or '-' characters are not present in the first character
//       position, the number is assumed to represent a positive
//       numeric value ('+'). In addition to leading plus or minus
//       characters, the number string may contain a decimal point
//       separating integer and fractional digits. All other
//       characters in this number string must be numeric digits.
//
//
//  shiftLeftPrecision  uint
//     - The number of digits by which the current decimal point
//       point position in the number string, 'signedNumStr' will
//       be shifted to the left.
//
//
//  ePrefix             string
//     - This is an error prefix which is included in all returned
//       error messages. Usually, it contains the names of the calling
//       method or methods. Note: Be sure to leave a space at the end
//       of 'ePrefix'.
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  newNumStrDto        NumStrDto
//     - If successful, the method returns the result of the Shift Left
//       precision operation in the form of a new 'NumStrDto' instance.
//
//
//  err                error
//     - If this method completes successfully, the returned error Type is
//       set equal to 'nil'. If errors are encountered during processing,
//       the returned error Type will encapsulate an error message. Note
//       that this error message will incorporate the method chain and text
//       passed by input parameter, 'ePrefix'.
//
//
// ------------------------------------------------------------------------
//
// Example Usage
//
//
//                               Shift-Left
//  signedNumStr    precision     Result
//  "123456.789"       3        "123.456789"
//  "123456.789"       2       "1234.56789"
//  "123456.789"       6          "0.123456789"
//  "123456789"        6        "123.456789"
//  "123"              5          "0.00123"
//   "0"               3          "0.000"
//   "0.000"           2          "0.00000"
//  "123456.789"       0     "123456.789"      - zero 'shiftPrecision' has no effect on
//                                               original number string
// "-123456.789"       0       "-123.456789"
// "-123456.789"       3       "-123.456789"
// "-123456789"        6       "-123.456789"
//
func (nStrDtoMolecule *numStrDtoMolecule) shiftPrecisionLeft(
	numSeparators NumericSeparatorDto,
	signedNumStr string,
	shiftLeftPrecision uint,
	ePrefix string) (
	newNumStrDto NumStrDto,
	err error) {

	if nStrDtoMolecule.lock == nil {
		nStrDtoMolecule.lock = new(sync.Mutex)
	}

	nStrDtoMolecule.lock.Lock()

	defer nStrDtoMolecule.lock.Unlock()

	ePrefix += "numStrDtoMolecule.shiftPrecisionLeft() "

	err = nil

	nStrDtoElectron := numStrDtoElectron{}

	newNumStrDto =
		nStrDtoElectron.newBaseZeroNumStrDto(0)

	if len(signedNumStr) == 0 {
		err = errors.New(ePrefix + "\n" +
			"Error: Input parameter 'signedNumStr' is INVALID!\n" +
			"'signedNumStr' is a zero length number string!\n")

		return newNumStrDto, err
	}

	// Set defaults for thousands separators,
	// decimal separators and currency Symbols
	numSeparators.SetToUSADefaultsIfEmpty()

	err = nStrDtoElectron.setNumericSeparatorsDto(
		&newNumStrDto,
		numSeparators,
		ePrefix+"Setting 'newNumStrDto' numeric separators ")

	if err != nil {
		return newNumStrDto, err
	}

	var n1 NumStrDto

	nStrDtoAtom := numStrDtoAtom{}

	n1,
		err = nStrDtoAtom.parseNumStr(
		signedNumStr,
		numSeparators,
		ePrefix+"signedNumStr -> n1 ")

	if err != nil {
		return newNumStrDto, err
	}

	n2 := NumStrDto{}.New()

	n2.absAllNumRunes = make([]rune, 0, 40)

	err = nStrDtoElectron.setNumericSeparatorsDto(
		&n2,
		numSeparators,
		ePrefix+"Setting 'n2' numeric separators ")

	if err != nil {
		return newNumStrDto, err
	}

	n2.signVal = n1.signVal

	n2.precision = shiftLeftPrecision + n1.precision

	iTotalSpecPrecision := int(n2.precision)
	lenAbsAllNumRunes := len(n1.absAllNumRunes)

	var lenAbsIntRunes, lenAbsFracRunes int

	lenAbsIntRunes =
		nStrDtoElectron.getAbsIntRunesLength(&n1)

	lenAbsFracRunes =
		nStrDtoElectron.getAbsFracRunesLength(&n1)

	var isZeroValue bool

	isZeroValue,
		err = nStrDtoElectron.isNumStrZeroValue(
		&n1,
		ePrefix+"n1 ")

	if err != nil {
		return newNumStrDto, err
	}

	if isZeroValue {

		newNumStrDto =
			nStrDtoElectron.newBaseZeroNumStrDto(n2.precision)

		return newNumStrDto, err
	}

	if iTotalSpecPrecision == lenAbsAllNumRunes {

		n2.absAllNumRunes = append(n2.absAllNumRunes, '0')

	} else if iTotalSpecPrecision > lenAbsAllNumRunes {

		deltaPrecision := iTotalSpecPrecision - lenAbsAllNumRunes + 1

		for i := 0; i < deltaPrecision; i++ {
			n2.absAllNumRunes = append(n2.absAllNumRunes, '0')
		}

	}

	for j := 0; j < lenAbsAllNumRunes; j++ {
		n2.absAllNumRunes = append(n2.absAllNumRunes, n1.absAllNumRunes[j])
	}

	lenAbsAllNumRunes = len(n2.absAllNumRunes)
	lenAbsFracRunes = iTotalSpecPrecision
	lenAbsIntRunes = lenAbsAllNumRunes - lenAbsFracRunes

	if lenAbsIntRunes <= 0 {
		err = fmt.Errorf(ePrefix+
			"Calculated number of integer digits is less than or equal to ZERO. "+
			"lenAbsIntRunes= '%v' ",
			lenAbsIntRunes)
		return newNumStrDto, err
	}

	//lenAbsFracRunes =
	//	numStrDtoElectron.getAbsFracRunesLength(&n2)

	newNumStrDto,
		err = nStrDtoElectron.copyOut(
		&n2,
		ePrefix+"n2 -> newNumStrDto ")

	if err != nil {
		return newNumStrDto, err
	}

	_,
		err = nStrDtoElectron.testNumStrDtoValidity(
		&newNumStrDto,
		ePrefix+"Final validation 'newNumStrDto' ")

	return newNumStrDto, err
}

// shiftPrecisionRight - Shifts the relative precision of a decimal
// point with a number string. The position of the decimal point is
// shifted 'shiftRightPrecision' positions to the right of the
// original decimal point position.
//
// This is equivalent to: result = signedNumStr X 10^shiftRightPrecision
// or signedNumStr Multiplied by 10 raised to the power of
// 'shiftRightPrecision'.
//
// See the Example Usage section below.
//
// -----------------------------------------------------------------
//
// Input Parameters
//
//  numSeparators       NumericSeparatorDto
//     - The numeric separator values contained in this input
//       parameter will be copied to the returned input parameter
//       'newNumStrDto', a newly created instance of NumStrDto.
//
//       The data fields included in the NumericSeparatorDto are
//       listed as follows:
//
//          type NumericSeparatorDto struct {
//
//            DecimalSeparator   rune // Character used to separate
//                                    //  integer and fractional digits ('.')
//
//            ThousandsSeparator rune // Character used to separate thousands
//                                    //  (1,000,000,000
//
//            CurrencySymbol     rune // Currency Symbol
//          }
//
//       If any of the data fields in this passed structure 'customSeparators'
//       are set to zero ('0'), they will be reset to USA default values.
//       USA default numeric separators are listed as follows:
//             Currency Symbol: '$'
//         Thousands Separator: ','
//           Decimal Separator: '.'
//
//
//  signedNumStr        string
//     - A valid number string. The leading digit may optionally
//       be a '+' or '-' indicating numeric sign value. If '+'
//       or '-' characters are not present in the first character
//       position, the number is assumed to represent a positive
//       numeric value ('+'). In addition to leading plus or minus
//       characters, the number string may contain a decimal point
//       separating integer and fractional digits. All other
//       characters in this number string must be numeric digits.
//
//
//  shiftRightPrecision uint
//     - The number of digits by which the current decimal point
//       point position in the number string, 'signedNumStr' will
//       be shifted to the right.
//
//
//  ePrefix             string
//     - This is an error prefix which is included in all returned
//       error messages. Usually, it contains the names of the calling
//       method or methods. Note: Be sure to leave a space at the end
//       of 'ePrefix'.
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  newNumStrDto        NumStrDto
//     - If successful, the method returns the result of the Shift Left
//       precision operation in the form of a new 'NumStrDto' instance.
//
//
//  err                error
//     - If successful the returned error Type is set equal to 'nil'.
//       If errors are encountered during processing, the returned
//       error Type will encapsulate an error message. Note this error
//       message will incorporate the method chain and text passed
//       by input parameter, 'ePrefix'.
//
//
// ------------------------------------------------------------------------
//
// Example Usage
//
// Notice that Zero 'shiftRightPrecision' has no effect on the original
// number string.
//
//   -------------------------------------------------------
//   signedNumStr   shiftRightPrecision       Result
//   -------------------------------------------------------
//   "123456.789"            3              "123456789"
//   "123456.789"            2              "12345678.9"
//   "123456.789"            6              "123456789000"
//   "123456789"             6              "123456789000000"
//   "123"                   5              "12300000"
//   "0"                     3              "0"
//   "123456.789"            0              "123456.789"
//  "-123456.789"            0             "-123456.789"
//  "-123456.789"            3             "-123456789"
//  "-123456789"             6             "-123456789000000"
//
func (nStrDtoMolecule *numStrDtoMolecule) shiftPrecisionRight(
	numSeparators NumericSeparatorDto,
	signedNumStr string,
	shiftRightPrecision uint,
	ePrefix string) (
	newNumStrDto NumStrDto,
	err error) {

	if nStrDtoMolecule.lock == nil {
		nStrDtoMolecule.lock = new(sync.Mutex)
	}

	nStrDtoMolecule.lock.Lock()

	defer nStrDtoMolecule.lock.Unlock()

	ePrefix += "numStrDtoMolecule.shiftPrecisionRight() "

	err = nil

	nStrDtoElectron := numStrDtoElectron{}

	newNumStrDto =
		nStrDtoElectron.newBaseZeroNumStrDto(0)

	if len(signedNumStr) == 0 {
		err = errors.New(ePrefix + "\n" +
			"Error: Input parameter 'signedNumStr' is INVALID!\n" +
			"'signedNumStr' is a zero length number string!\n")

		return newNumStrDto, err
	}

	// Set defaults for thousands separators,
	// decimal separators and currency Symbols
	numSeparators.SetToUSADefaultsIfEmpty()

	err = nStrDtoElectron.setNumericSeparatorsDto(
		&newNumStrDto,
		numSeparators,
		ePrefix+"Setting 'newNumStrDto' numeric separators ")

	if err != nil {
		return newNumStrDto, err
	}

	var n1 NumStrDto

	nStrDtoAtom := numStrDtoAtom{}

	n1,
		err = nStrDtoAtom.parseNumStr(
		signedNumStr,
		numSeparators,
		ePrefix+"signedNumStr -> n1 ")

	if err != nil {
		return newNumStrDto, err
	}

	n2 := NumStrDto{}.New()

	n2.absAllNumRunes = make([]rune, 0, 40)

	err = nStrDtoElectron.setNumericSeparatorsDto(
		&n2,
		numSeparators,
		ePrefix+"Setting 'n2' numeric separators ")

	if err != nil {
		return newNumStrDto, err
	}

	iTotalSpecPrecision := 0
	iPrecision := int(shiftRightPrecision)
	iN1Precision := int(n1.precision)

	if iN1Precision > 0 && iPrecision < iN1Precision {
		iTotalSpecPrecision = iN1Precision - iPrecision
	} else {
		iTotalSpecPrecision = 0
	}

	n2.signVal = n1.signVal

	n2.precision = uint(iTotalSpecPrecision)

	lenAbsAllNumRunes := len(n1.absAllNumRunes)

	var isZeroValue bool

	isZeroValue,
		err = nStrDtoElectron.isNumStrZeroValue(
		&n1,
		ePrefix+"n1 ")

	if err != nil {
		return newNumStrDto, err
	}

	if isZeroValue {

		newNumStrDto =
			nStrDtoElectron.newBaseZeroNumStrDto(n2.precision)

		return newNumStrDto, err
	}

	if int(shiftRightPrecision) > int(n1.precision) {

		for i := 0; i < lenAbsAllNumRunes; i++ {
			n2.absAllNumRunes = append(n2.absAllNumRunes, n1.absAllNumRunes[i])
		}

		deltaPrecision := int(shiftRightPrecision) - int(n1.precision)

		for i := 0; i < deltaPrecision; i++ {
			n2.absAllNumRunes = append(n2.absAllNumRunes, '0')
		}

	} else {

		for i := 0; i < lenAbsAllNumRunes; i++ {
			n2.absAllNumRunes = append(n2.absAllNumRunes, n1.absAllNumRunes[i])
		}

	}

	lenAbsAllNumRunes = len(n2.absAllNumRunes)
	lenAbsFracRunes := iTotalSpecPrecision
	lenAbsIntRunes := lenAbsAllNumRunes - lenAbsFracRunes

	if lenAbsIntRunes <= 0 {
		err = fmt.Errorf(ePrefix+"\n"+
			"Calculated number of integer digits is less than or equal to ZERO.\n"+
			"lenAbsIntRunes= '%v'\n", lenAbsIntRunes)

		return newNumStrDto, err
	}

	//lenAbsFracRunes =
	//	numStrDtoElectron.getAbsFracRunesLength(&n2)

	newNumStrDto,
		err = nStrDtoElectron.copyOut(
		&n2,
		ePrefix+"n2 -> newNumStrDto ")

	if err != nil {
		return newNumStrDto, err
	}

	_,
		err = nStrDtoElectron.testNumStrDtoValidity(
		&newNumStrDto,
		ePrefix+"Final validation 'newNumStrDto' ")

	return newNumStrDto, err
}
